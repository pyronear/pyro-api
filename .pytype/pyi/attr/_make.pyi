# (generated with --quick)

import __future__
import attr.exceptions
import types
from typing import Any, Callable, Dict, List, NoReturn, Tuple, Type, TypeVar, Union

DefaultAlreadySetError: Type[attr.exceptions.DefaultAlreadySetError]
Factory: Any
FrozenInstanceError: Type[attr.exceptions.FrozenInstanceError]
NOTHING: _Nothing
NotAnAttrsClassError: Type[attr.exceptions.NotAnAttrsClassError]
PY2: bool
PythonTooOldError: Type[attr.exceptions.PythonTooOldError]
UnannotatedAttributeError: Type[attr.exceptions.UnannotatedAttributeError]
_AndValidator: Any
_Attributes: Union[Callable, Type[property]]
_CMP_DEPRECATION: str
_a: List[Attribute]
_already_repring: threading.local
_classvar_prefixes: Tuple[str, str, str]
_config: module
_empty_metadata_singleton: types.MappingProxyType[nothing, nothing]
_hash_cache_field: str
_init_converter_pat: str
_init_factory_pat: str
_sentinel: Any
_tuple_property_pat: str
absolute_import: __future__._Feature
copy: module
division: __future__._Feature
linecache: module
ordered_dict: Type[dict]
print_function: __future__._Feature
set_closure_cell: Any
setters: module
sys: module
threading: module
uuid: module
warnings: module

_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_TAttribute = TypeVar('_TAttribute', bound=Attribute)
_T_ClassBuilder = TypeVar('_T_ClassBuilder', bound=_ClassBuilder)
_T_Nothing = TypeVar('_T_Nothing', bound=_Nothing)

class Attribute:
    __slots__ = ["converter", "default", "eq", "hash", "inherited", "init", "kw_only", "metadata", "name", "on_setattr", "order", "repr", "type", "validator"]
    __doc__: str
    __eq__: Any
    __hash__: Any
    cmp: Any
    def __getstate__(self) -> tuple: ...
    def __init__(self, name, default, validator, repr, cmp, hash, init, inherited, metadata = ..., type = ..., converter = ..., kw_only = ..., eq = ..., order = ..., on_setattr = ...) -> None: ...
    def __ne__(self: Union[Attribute, _CountingAttr], other) -> Union[NotImplementedType, bool]: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, name, value) -> NoReturn: ...
    def __setstate__(self, state) -> None: ...
    def _assoc(self: _TAttribute, **changes) -> _TAttribute: ...
    def _setattrs(self, name_values_pairs) -> None: ...
    @classmethod
    def from_counting_attr(cls: Type[_TAttribute], name, ca, type = ...) -> _TAttribute: ...

class _CacheHashWrapper(int):
    __doc__: str
    def __reduce__(self, _none_constructor: _T0 = ..., _args: _T1 = ...) -> Tuple[_T0, _T1]: ...

class _ClassBuilder:
    __slots__ = ["_attr_names", "_attrs", "_base_attr_map", "_base_names", "_cache_hash", "_cls", "_cls_dict", "_delete_attribs", "_frozen", "_has_custom_setattr", "_has_own_setattr", "_has_post_init", "_is_exc", "_on_setattr", "_slots", "_weakref_slot"]
    __doc__: str
    _attr_names: tuple
    _attrs: Any
    _base_attr_map: Any
    _base_names: set
    _cache_hash: Any
    _cls: Any
    _cls_dict: dict
    _delete_attribs: bool
    _frozen: Any
    _has_custom_setattr: Any
    _has_own_setattr: bool
    _has_post_init: bool
    _is_exc: Any
    _on_setattr: Any
    _slots: Any
    _weakref_slot: Any
    def __init__(self, cls, these, slots, frozen, weakref_slot, getstate_setstate, auto_attribs, kw_only, cache_hash, is_exc, collect_by_mro, on_setattr, has_custom_setattr) -> None: ...
    def __repr__(self) -> str: ...
    def _add_method_dunders(self, method: _T0) -> _T0: ...
    def _create_slots_class(self) -> Any: ...
    def _make_getstate_setstate(self) -> Tuple[Callable[[Any], Any], Callable[[Any, Any], Any]]: ...
    def _patch_original_class(self) -> Any: ...
    def add_eq(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_hash(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_init(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_order(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_repr(self: _T_ClassBuilder, ns) -> _T_ClassBuilder: ...
    def add_setattr(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def add_str(self: _T_ClassBuilder) -> _T_ClassBuilder: ...
    def build_class(self) -> Any: ...
    def make_unhashable(self: _T_ClassBuilder) -> _T_ClassBuilder: ...

class _CountingAttr:
    __slots__ = ["_default", "_validator", "converter", "counter", "eq", "hash", "init", "kw_only", "metadata", "on_setattr", "order", "repr", "type"]
    __attrs_attrs__: Tuple[Attribute, ...]
    __doc__: str
    __eq__: Any
    _default: Any
    _validator: Any
    cls_counter: int
    converter: Any
    counter: int
    eq: Any
    hash: Any
    init: Any
    kw_only: Any
    metadata: Any
    on_setattr: Any
    order: Any
    repr: Any
    type: Any
    def __init__(self, default, validator, repr, cmp, hash, init, converter, metadata, type, kw_only, eq, order, on_setattr) -> None: ...
    def __ne__(self: Union[Attribute, _CountingAttr], other) -> Union[NotImplementedType, bool]: ...
    def __repr__(self) -> str: ...
    def default(self, meth: _T0) -> _T0: ...
    def validator(self, meth: _T0) -> _T0: ...

class _Nothing:
    __doc__: str
    _singleton: _Nothing
    def __new__(cls: Type[_T_Nothing]) -> _T_Nothing: ...
    def __repr__(self) -> str: ...

def _add_eq(cls: _T0, attrs = ...) -> _T0: ...
def _add_hash(cls: _T0, attrs) -> _T0: ...
def _add_repr(cls: _T0, ns = ..., attrs = ...) -> _T0: ...
def _assign(attr_name, value, has_on_setattr) -> Any: ...
def _assign_with_converter(attr_name, value_var, has_on_setattr) -> Any: ...
def _attrs(maybe_cls = ..., these = ..., repr_ns = ..., repr = ..., cmp = ..., hash = ..., init = ..., slots = ..., frozen = ..., weakref_slot = ..., str = ..., auto_attribs = ..., kw_only = ..., cache_hash = ..., auto_exc = ..., eq = ..., order = ..., auto_detect = ..., collect_by_mro = ..., getstate_setstate = ..., on_setattr = ...) -> Any: ...
def _attrs_to_init_script(attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc, needs_cached_setattr, has_global_on_setattr) -> Tuple[str, Dict[str, Any], dict]: ...
def _attrs_to_tuple(obj, attrs) -> tuple: ...
def _collect_base_attrs(cls, taken_attr_names) -> Tuple[list, dict]: ...
def _collect_base_attrs_broken(cls, taken_attr_names) -> Tuple[list, dict]: ...
def _counter_getter(e) -> Any: ...
def _determine_eq_order(cmp: _T0, eq: _T1, order: _T2, default_eq: _T3) -> Tuple[Union[_T0, _T1, _T3], Union[_T0, _T1, _T2, _T3]]: ...
def _determine_whether_to_implement(cls, flag: _T1, auto_detect, dunders, default: _T4 = ...) -> Union[bool, _T1, _T4]: ...
def _frozen_delattrs(self, name) -> NoReturn: ...
def _frozen_setattrs(self, name, value) -> NoReturn: ...
def _generate_unique_filename(cls, func_name) -> str: ...
def _get_annotations(cls) -> Any: ...
def _has_frozen_base_class(cls) -> Any: ...
def _has_own_attribute(cls, attrib_name) -> bool: ...
def _is_class_var(annot) -> bool: ...
def _is_slot_attr(a_name, base_attr_map) -> Any: ...
def _is_slot_cls(cls) -> bool: ...
def _make_attr_tuple_class(cls_name, attr_names) -> Union[Callable, Type[property]]: ...
def _make_eq(cls, attrs) -> Any: ...
def _make_hash(cls, attrs, frozen, cache_hash) -> Any: ...
def _make_init(cls, attrs, post_init, frozen, slots, cache_hash, base_attr_map, is_exc, has_global_on_setattr) -> Any: ...
def _make_ne() -> Callable[[Any, Any], Any]: ...
def _make_order(cls, attrs) -> Tuple[Callable[[Any, Any], Any], Callable[[Any, Any], Any], Callable[[Any, Any], Any], Callable[[Any, Any], Any]]: ...
def _make_repr(attrs, ns) -> Callable[[Any], Any]: ...
def _obj_setattr(self: object, name, value) -> None: ...
def _setattr(attr_name, value_var, has_on_setattr) -> str: ...
def _setattr_with_converter(attr_name, value_var, has_on_setattr) -> str: ...
def _transform_attrs(cls, these, auto_attribs, kw_only, collect_by_mro) -> Union[Callable[[Any], Any], property]: ...
def and_(*validators) -> Any: ...
def attrib(default = ..., validator = ..., repr = ..., cmp = ..., hash = ..., init = ..., metadata = ..., type = ..., converter = ..., factory = ..., kw_only = ..., eq = ..., order = ..., on_setattr = ...) -> _CountingAttr: ...
def attrs(maybe_cls = ..., these = ..., repr_ns = ..., repr = ..., cmp = ..., hash = ..., init = ..., slots = ..., frozen = ..., weakref_slot = ..., str = ..., auto_attribs = ..., kw_only = ..., cache_hash = ..., auto_exc = ..., eq = ..., order = ..., auto_detect = ..., collect_by_mro = ..., getstate_setstate = ..., on_setattr = ...) -> Any: ...
def fields(cls) -> Any: ...
def fields_dict(cls) -> dict: ...
def isclass(klass) -> bool: ...
def itemgetter(*items) -> Callable[[Any], tuple]: ...
def iteritems(d) -> Any: ...
def make_class(name, attrs, bases = ..., **attributes_arguments) -> Any: ...
def metadata_proxy(d) -> types.MappingProxyType[nothing, nothing]: ...
def pipe(*converters) -> Callable[[Any], Any]: ...
def validate(inst) -> None: ...
