# (generated with --quick)

import collections
import typing
from typing import Any, Callable, Coroutine, IO, ItemsView, Iterable, Iterator, KeysView, List, Mapping, MutableMapping, Optional, Sized, Tuple, Type, TypeVar, Union, ValuesView
import urllib.parse

Address = `namedtuple-Address-host-port`
Scope = MutableMapping[str, Any]

Sequence: Type[typing.Sequence]
SplitResult: Type[urllib.parse.SplitResult]
shlex: Type[shlex.shlex]
tempfile: module
typing: module

AnyStr = TypeVar('AnyStr', str, bytes)
T = TypeVar('T')
_TURL = TypeVar('_TURL', bound=URL)
_TURLPath = TypeVar('_TURLPath', bound=URLPath)
_Tnamedtuple-Address-host-port = TypeVar('_Tnamedtuple-Address-host-port', bound=`namedtuple-Address-host-port`)

class CommaSeparatedStrings(typing.Sequence):
    _items: Any
    def __getitem__(self, index: Union[int, slice]) -> Any: ...
    def __init__(self, value: Union[str, typing.Sequence[str]]) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class FormData(ImmutableMultiDict):
    __doc__: str
    _dict: Any
    _list: list
    def __init__(self, *args: Union[FormData, List[Tuple[str, Union[UploadFile, str]]], Mapping[str, Union[UploadFile, str]]], **kwargs: Union[UploadFile, str]) -> None: ...
    def close(self) -> Coroutine[Any, Any, None]: ...

class Headers(Mapping[str, str]):
    __doc__: str
    _list: List[Tuple[bytes, bytes]]
    raw: List[Tuple[bytes, bytes]]
    def __contains__(self, key) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __getitem__(self, key: str) -> str: ...
    def __init__(self, headers: Mapping[str, str] = ..., raw: List[Tuple[bytes, bytes]] = ..., scope: MutableMapping[str, Any] = ...) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def get(self, key: str, default = ...) -> Any: ...
    def getlist(self, key: str) -> List[str]: ...
    def items(self) -> List[Tuple[str, str]]: ...
    def keys(self) -> List[str]: ...
    def mutablecopy(self) -> MutableHeaders: ...
    def values(self) -> List[str]: ...

class ImmutableMultiDict(Mapping):
    _dict: Any
    _list: list
    def __contains__(self, key) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __getitem__(self, key) -> str: ...
    def __init__(self, *args: Union[Mapping, List[Tuple[Any, Any]]], **kwargs) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def get(self, key, default = ...) -> Any: ...
    def getlist(self, key) -> List[str]: ...
    def items(self) -> ItemsView: ...
    def keys(self) -> KeysView: ...
    def multi_items(self) -> List[Tuple[str, str]]: ...
    def values(self) -> ValuesView: ...

class MultiDict(ImmutableMultiDict):
    _dict: Any
    _list: list
    def __delitem__(self, key) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def append(self, key, value) -> None: ...
    def clear(self) -> None: ...
    def pop(self, key, default = ...) -> Any: ...
    def popitem(self) -> tuple: ...
    def poplist(self, key) -> list: ...
    def setdefault(self, key, default = ...) -> Any: ...
    def setlist(self, key, values: list) -> None: ...
    def update(self, *args: Union[Mapping, List[Tuple[Any, Any]]], **kwargs) -> None: ...

class MutableHeaders(Headers):
    _list: List[Tuple[bytes, bytes]]
    raw: List[Tuple[bytes, bytes]]
    def __delitem__(self, key: str) -> None: ...
    def __setitem__(self, key: str, value: str) -> None: ...
    def add_vary_header(self, vary: str) -> None: ...
    def append(self, key: str, value: str) -> None: ...
    def setdefault(self, key: str, value: str) -> str: ...
    def update(self, other: dict) -> None: ...

class QueryParams(ImmutableMultiDict):
    __doc__: str
    _dict: Any
    _list: Any
    def __init__(self, *args: Union[bytes, str, Mapping, List[Tuple[Any, Any]]], **kwargs) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class Secret:
    __doc__: str
    _value: str
    def __init__(self, value: str) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class State:
    __doc__: str
    def __delattr__(self, key) -> None: ...
    def __getattr__(self, key) -> Any: ...
    def __init__(self, state: dict = ...) -> None: ...
    def __setattr__(self, key, value) -> None: ...

class URL:
    _url: Any
    components: urllib.parse.SplitResult
    fragment: str
    hostname: Optional[str]
    is_secure: bool
    netloc: str
    password: Optional[str]
    path: str
    port: Optional[int]
    query: str
    scheme: str
    username: Optional[str]
    def __eq__(self, other) -> bool: ...
    def __init__(self, url: str = ..., scope: MutableMapping[str, Any] = ..., **components) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def include_query_params(self: _TURL, **kwargs) -> _TURL: ...
    def remove_query_params(self: _TURL, keys: Union[str, typing.Sequence[str]]) -> _TURL: ...
    def replace(self: _TURL, **kwargs) -> _TURL: ...
    def replace_query_params(self: _TURL, **kwargs) -> _TURL: ...

class URLPath(str):
    __doc__: str
    host: str
    protocol: str
    def __init__(self, path: str, protocol: str = ..., host: str = ...) -> None: ...
    def __new__(cls: Type[_TURLPath], path: str, protocol: str = ..., host: str = ...) -> _TURLPath: ...
    def make_absolute_url(self, base_url: Union[URL, str]) -> str: ...

class UploadFile:
    __doc__: str
    _in_memory: bool
    content_type: str
    file: IO[Union[bytes, str]]
    filename: str
    spool_max_size: int
    def __init__(self, filename: str, file: IO = ..., content_type: str = ...) -> None: ...
    def close(self) -> Coroutine[Any, Any, None]: ...
    def read(self, size: int = ...) -> Coroutine[Any, Any, Union[bytes, str]]: ...
    def seek(self, offset: int) -> Coroutine[Any, Any, None]: ...
    def write(self, data: Union[bytes, str]) -> Coroutine[Any, Any, None]: ...

class `namedtuple-Address-host-port`(tuple):
    __slots__ = ["host", "port"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str]
    host: Any
    port: Any
    def __getnewargs__(self) -> Tuple[Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-Address-host-port`], host, port) -> `_Tnamedtuple-Address-host-port`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-Address-host-port`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-Address-host-port`: ...
    def _replace(self: `_Tnamedtuple-Address-host-port`, **kwds) -> `_Tnamedtuple-Address-host-port`: ...

def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: bool = ..., rename: bool = ...) -> type: ...
def parse_qsl(qs: Optional[AnyStr], keep_blank_values: bool = ..., strict_parsing: bool = ..., encoding: str = ..., errors: str = ..., max_num_fields: Optional[int] = ...) -> List[Tuple[AnyStr, AnyStr]]: ...
def run_in_threadpool(func: Callable[..., T], *args, **kwargs) -> coroutine: ...
def urlencode(query: Union[Mapping, typing.Sequence[Tuple[Any, Any]]], doseq: bool = ..., safe: AnyStr = ..., encoding: str = ..., errors: str = ..., quote_via: Callable[[str, AnyStr, str, str], str] = ...) -> str: ...
@overload
def urlsplit(url: str, scheme: Optional[str] = ..., allow_fragments: bool = ...) -> urllib.parse.SplitResult: ...
@overload
def urlsplit(url: Optional[bytes], scheme: Optional[bytes] = ..., allow_fragments: bool = ...) -> urllib.parse.SplitResultBytes: ...
