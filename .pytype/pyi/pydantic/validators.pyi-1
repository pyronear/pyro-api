# (generated with --quick)

import collections
import decimal
import enum
import ipaddress
import pathlib
import typing
from typing import Any, Callable, Generator, List, Pattern, Set, Tuple, Type, TypeVar, Union
import uuid

AnyOrderedDict = collections.OrderedDict

AnyCallable: Any
BOOL_FALSE: Set[Union[int, str]]
BOOL_TRUE: Set[Union[int, str]]
BaseConfig: Any
ConstrainedDecimal: Any
ConstrainedFloat: Any
ConstrainedInt: Any
ConstrainedNumber: Any
Decimal: Type[decimal.Decimal]
DecimalException: Type[decimal.DecimalException]
Enum: Type[enum.Enum]
ForwardRef: Any
Hashable: Type[typing.Hashable]
IPv4Address: Type[ipaddress.IPv4Address]
IPv4Interface: Type[ipaddress.IPv4Interface]
IPv4Network: Type[ipaddress.IPv4Network]
IPv6Address: Type[ipaddress.IPv6Address]
IPv6Interface: Type[ipaddress.IPv6Interface]
IPv6Network: Type[ipaddress.IPv6Network]
IntEnum: Type[enum.IntEnum]
ModelField: Any
Number: Type[Union[float, int, decimal.Decimal]]
OrderedDict: Type[collections.OrderedDict]
Path: Type[pathlib.Path]
StrBytes: Type[Union[bytes, str]]
UUID: Type[uuid.UUID]
_VALIDATORS: List[Tuple[type, list]]
all_literal_values: Any
almost_equal_floats: Any
date: Type[datetime.date]
datetime: Type[datetime.datetime]
display_as_type: Any
errors: Any
get_class: Any
is_callable_type: Any
is_literal_type: Any
lenient_issubclass: Any
parse_date: Any
parse_datetime: Any
parse_duration: Any
parse_time: Any
re: module
sequence_like: Any
time: Type[datetime.time]
timedelta: Type[datetime.timedelta]

T = TypeVar('T')

class IfConfig:
    config_attr_names: Tuple[str, ...]
    validator: Any
    def __init__(self, validator, *config_attr_names: str) -> None: ...
    def check(self, config: type) -> bool: ...

def any_class_validator(v) -> Type[T]: ...
def anystr_length_validator(v: Union[bytes, str], config) -> Union[bytes, str]: ...
def anystr_strip_whitespace(v: Union[bytes, str]) -> Union[bytes, str]: ...
def bool_validator(v) -> bool: ...
def bytes_validator(v) -> bytes: ...
def callable_validator(v) -> Any: ...
def constant_validator(v, field) -> Any: ...
def constr_length_validator(v: Union[bytes, str], field, config) -> Union[bytes, str]: ...
def constr_strip_whitespace(v: Union[bytes, str], field, config) -> Union[bytes, str]: ...
def decimal_validator(v) -> decimal.Decimal: ...
def dict_validator(v) -> dict: ...
def enum_validator(v, field, config) -> enum.Enum: ...
def find_validators(type_: type, config: type) -> Generator[Any, None, None]: ...
def float_validator(v) -> float: ...
def frozenset_validator(v) -> frozenset: ...
def hashable_validator(v) -> typing.Hashable: ...
def int_validator(v) -> int: ...
def ip_v4_address_validator(v) -> ipaddress.IPv4Address: ...
def ip_v4_interface_validator(v) -> ipaddress.IPv4Interface: ...
def ip_v4_network_validator(v) -> ipaddress.IPv4Network: ...
def ip_v6_address_validator(v) -> ipaddress.IPv6Address: ...
def ip_v6_interface_validator(v) -> ipaddress.IPv6Interface: ...
def ip_v6_network_validator(v) -> ipaddress.IPv6Network: ...
def list_validator(v) -> list: ...
def make_arbitrary_type_validator(type_: Type[T]) -> Callable[[T], T]: ...
def make_class_validator(type_: Type[T]) -> Callable[[Any], Type[T]]: ...
def make_literal_validator(type_) -> Callable[[Any], Any]: ...
def number_multiple_validator(v: Union[float, decimal.Decimal], field) -> Union[float, int, decimal.Decimal]: ...
def number_size_validator(v: Union[float, decimal.Decimal], field) -> Union[float, int, decimal.Decimal]: ...
def ordered_dict_validator(v) -> collections.OrderedDict: ...
def path_exists_validator(v) -> pathlib.Path: ...
def path_validator(v) -> pathlib.Path: ...
def pattern_validator(v) -> Pattern[str]: ...
def set_validator(v) -> set: ...
def str_validator(v) -> str: ...
def strict_float_validator(v) -> float: ...
def strict_int_validator(v) -> int: ...
def strict_str_validator(v) -> str: ...
def tuple_validator(v) -> tuple: ...
def uuid_validator(v, field) -> uuid.UUID: ...
def validate_json(v, config) -> Any: ...
