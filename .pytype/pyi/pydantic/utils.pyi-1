# (generated with --quick)

import inspect
import types
from typing import Any, Callable, Dict, Generator, Iterable, Iterator, List, Optional, Tuple, Type, TypeVar, Union

AbstractSetIntStr: Any
BaseConfig: Any
BaseModel: Any
DataclassType: Any
DictIntStrAny: Any
GeneratorType: Type[types.GeneratorType]
IntStr: Any
MappingIntStrAny: Any
ModelField: Any
ReprArgs: Any
Signature: Type[inspect.Signature]
__all__: Tuple[str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str]
display_as_type: Any
version_info: Any
warnings: module

KeyType = TypeVar('KeyType')
T = TypeVar('T')
_T = TypeVar('_T')

class ClassAttribute:
    __slots__ = ["name", "value"]
    __doc__: str
    name: str
    value: Any
    def __get__(self, instance, owner: type) -> None: ...
    def __init__(self, name: str, value) -> None: ...

class GetterDict(Representation):
    __slots__ = ["_obj"]
    __doc__: str
    _obj: Any
    def __contains__(self, item) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __init__(self, obj) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __repr_args__(self) -> Any: ...
    def __repr_name__(self) -> str: ...
    def extra_keys(self) -> set: ...
    def get(self, key, default = ...) -> Any: ...
    def items(self) -> Iterator[Tuple[str, Any]]: ...
    def keys(self) -> list: ...
    def values(self) -> list: ...

class PyObjectStr(str):
    __doc__: str
    def __repr__(self) -> str: ...

class Representation:
    __doc__: str
    __slots__: Tuple[str, ...]
    def __pretty__(self, fmt: Callable[[Any], Any], **kwargs) -> Generator[Any, None, None]: ...
    def __repr__(self) -> str: ...
    def __repr_args__(self) -> Any: ...
    def __repr_name__(self) -> str: ...
    def __repr_str__(self, join_str: str) -> str: ...
    def __str__(self) -> str: ...

class ValueItems(Representation):
    __slots__ = ["_items", "_type"]
    __doc__: str
    _items: Any
    _type: Type[Union[dict, set]]
    def __init__(self, value, items) -> None: ...
    def __repr_args__(self) -> Any: ...
    def _normalize_indexes(self, items, v_length: int) -> Any: ...
    def for_element(self, e) -> Any: ...
    def is_excluded(self, item) -> bool: ...
    def is_included(self, item) -> bool: ...

def almost_equal_floats(value_1: float, value_2: float, *, delta: float = ...) -> bool: ...
def deep_update(mapping: Dict[KeyType, Any], updating_mapping: Dict[KeyType, Any]) -> Dict[KeyType, Any]: ...
def generate_model_signature(init: Callable[..., None], fields: Dict[str, Any], config: type) -> inspect.Signature: ...
def get_model(obj: type) -> type: ...
def import_string(dotted_path: str) -> Any: ...
def in_ipython() -> bool: ...
@overload
def islice(iterable: Iterable[_T], start: Optional[int], stop: Optional[int], step: Optional[int] = ...) -> Iterator[_T]: ...
@overload
def islice(iterable: Iterable[_T], stop: Optional[int]) -> Iterator[_T]: ...
def lenient_issubclass(cls, class_or_tuple: Union[type, Tuple[type, ...]]) -> bool: ...
def sequence_like(v: type) -> bool: ...
def to_camel(string: str) -> str: ...
def truncate(v: str, *, max_len: int = ...) -> str: ...
def unique_list(input_list: Union[List[T], Tuple[T, ...]]) -> List[T]: ...
def update_normalized_all(item, all_items) -> Any: ...
def update_not_none(mapping: dict, **update) -> None: ...
def validate_field_name(bases: List[type], field_name: str) -> None: ...
