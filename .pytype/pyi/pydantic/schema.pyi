# (generated with --quick)

import decimal
import enum
import ipaddress
import pathlib
import pydantic.dataclasses
import pydantic.fields
import pydantic.main
import pydantic.networks
import pydantic.types
from typing import Any, Callable, Dict, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
import uuid

TypeModelSet = Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]

AnyUrl: Type[pydantic.networks.AnyUrl]
BaseModel: Type[pydantic.main.BaseModel]
ConstrainedDecimal: Type[pydantic.types.ConstrainedDecimal]
ConstrainedFloat: Type[pydantic.types.ConstrainedFloat]
ConstrainedInt: Type[pydantic.types.ConstrainedInt]
ConstrainedList: Type[pydantic.types.ConstrainedList]
ConstrainedSet: Type[pydantic.types.ConstrainedSet]
ConstrainedStr: Type[pydantic.types.ConstrainedStr]
DataclassType: Type[pydantic.dataclasses.DataclassType]
Decimal: Type[decimal.Decimal]
EmailStr: Type[pydantic.networks.EmailStr]
Enum: Type[enum.Enum]
FieldInfo: Type[pydantic.fields.FieldInfo]
ForwardRef: Any
IPv4Address: Type[ipaddress.IPv4Address]
IPv4Interface: Type[ipaddress.IPv4Interface]
IPv4Network: Type[ipaddress.IPv4Network]
IPv6Address: Type[ipaddress.IPv6Address]
IPv6Interface: Type[ipaddress.IPv6Interface]
IPv6Network: Type[ipaddress.IPv6Network]
Literal: Any
ModelField: Type[pydantic.fields.ModelField]
Path: Type[pathlib.Path]
ROOT_KEY: str
SHAPE_FROZENSET: int
SHAPE_ITERABLE: int
SHAPE_LIST: int
SHAPE_MAPPING: int
SHAPE_SEQUENCE: int
SHAPE_SET: int
SHAPE_SINGLETON: int
SHAPE_TUPLE: int
SHAPE_TUPLE_ELLIPSIS: int
TypeModelOrEnum: Type[Type[Union[enum.Enum, pydantic.main.BaseModel]]]
UUID: Type[uuid.UUID]
_field_constraints: Set[str]
_map_types_constraint: Dict[Any, Callable[..., type]]
_numeric_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...]
_str_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...]
date: Type[datetime.date]
datetime: Type[datetime.datetime]
default_prefix: str
field_class_to_schema: Tuple[Tuple[Any, Dict[str, Any]], ...]
json_scheme: Dict[str, str]
numeric_types: Tuple[Type[int], Type[float], Type[decimal.Decimal]]
re: module
time: Type[datetime.time]
timedelta: Type[datetime.timedelta]
warnings: module

T = TypeVar('T')

class SkipField(Exception):
    __doc__: str
    message: str
    def __init__(self, message: str) -> None: ...

def add_field_type_to_schema(field_type, schema: Dict[str, Any]) -> None: ...
def conbytes(*, strip_whitespace: bool = ..., min_length: int = ..., max_length: int = ...) -> Type[bytes]: ...
def condecimal(*, gt: decimal.Decimal = ..., ge: decimal.Decimal = ..., lt: decimal.Decimal = ..., le: decimal.Decimal = ..., max_digits: int = ..., decimal_places: int = ..., multiple_of: decimal.Decimal = ...) -> Type[decimal.Decimal]: ...
def confloat(*, strict: bool = ..., gt: float = ..., ge: float = ..., lt: float = ..., le: float = ..., multiple_of: float = ...) -> Type[float]: ...
def conint(*, strict: bool = ..., gt: int = ..., ge: int = ..., lt: int = ..., le: int = ..., multiple_of: int = ...) -> Type[int]: ...
def conlist(item_type: Type[T], *, min_items: int = ..., max_items: int = ...) -> Type[List[T]]: ...
def conset(item_type: Type[T], *, min_items: int = ..., max_items: int = ...) -> Type[Set[T]]: ...
def constr(*, strip_whitespace: bool = ..., strict: bool = ..., min_length: int = ..., max_length: int = ..., curtail_length: int = ..., regex: str = ...) -> Type[str]: ...
def encode_default(dft) -> Any: ...
def enum_process_schema(enum: Type[enum.Enum]) -> Dict[str, Any]: ...
def field_schema(field: pydantic.fields.ModelField, *, by_alias: bool = ..., model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]] = ...) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
def field_singleton_schema(field: pydantic.fields.ModelField, *, by_alias: bool, model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], schema_overrides: bool = ..., ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
def field_singleton_sub_fields_schema(sub_fields: Sequence[pydantic.fields.ModelField], *, by_alias: bool, model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], schema_overrides: bool = ..., ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
def field_type_schema(field: pydantic.fields.ModelField, *, by_alias: bool, model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], schema_overrides: bool = ..., ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
def get_annotation_from_field_info(annotation, field_info: pydantic.fields.FieldInfo, field_name: str) -> type: ...
def get_field_schema_validations(field: pydantic.fields.ModelField) -> Dict[str, Any]: ...
def get_flat_models_from_field(field: pydantic.fields.ModelField, known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]: ...
def get_flat_models_from_fields(fields: Sequence[pydantic.fields.ModelField], known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]: ...
def get_flat_models_from_model(model: Type[pydantic.main.BaseModel], known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]] = ...) -> Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]: ...
def get_flat_models_from_models(models: Sequence[Type[pydantic.main.BaseModel]]) -> Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]: ...
def get_long_model_name(model: Type[Union[enum.Enum, pydantic.main.BaseModel]]) -> str: ...
def get_model(obj: type) -> type: ...
def get_model_name_map(unique_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str]: ...
def is_callable_type(type_) -> bool: ...
def is_literal_type(type_) -> bool: ...
def lenient_issubclass(cls, class_or_tuple: Union[type, Tuple[type, ...]]) -> bool: ...
def literal_values(type_) -> Any: ...
def model_process_schema(model: Type[Union[enum.Enum, pydantic.main.BaseModel]], *, by_alias: bool = ..., model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]] = ...) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
def model_schema(model: Type[Union[pydantic.dataclasses.DataclassType, pydantic.main.BaseModel]], by_alias: bool = ..., ref_prefix: Optional[str] = ...) -> Dict[str, Any]: ...
def model_type_schema(model: Type[pydantic.main.BaseModel], *, by_alias: bool, model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]]) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
def multivalue_literal_field_for_schema(values: tuple, field: pydantic.fields.ModelField) -> pydantic.fields.ModelField: ...
def normalize_name(name: str) -> str: ...
def pydantic_encoder(obj) -> Any: ...
def schema(models: Sequence[Type[Union[pydantic.dataclasses.DataclassType, pydantic.main.BaseModel]]], *, by_alias: bool = ..., title: Optional[str] = ..., description: Optional[str] = ..., ref_prefix: Optional[str] = ...) -> Dict[str, Any]: ...
def sequence_like(v: type) -> bool: ...
