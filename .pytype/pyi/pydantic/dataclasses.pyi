# (generated with --quick)

import pydantic.error_wrappers
import pydantic.errors
import pydantic.main
from typing import Any, Callable, Dict, Generator, Optional, Tuple, Type, TypeVar, Union

BaseModel: Type[pydantic.main.BaseModel]
DataclassTypeError: Type[pydantic.errors.DataclassTypeError]
Required: Any
ValidationError: Type[pydantic.error_wrappers.ValidationError]

DataclassT = TypeVar('DataclassT', bound=DataclassType)

class DataclassType:
    __initialised__: bool
    __pydantic_model__: Type[pydantic.main.BaseModel]
    def __call__(self: DataclassT, *args, **kwargs) -> DataclassT: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def __validate__(cls: Type[DataclassT], v) -> DataclassT: ...

def _get_validators(cls: Type[DataclassT]) -> Generator[Any, None, None]: ...
def _process_class(_cls: type, init: bool, repr: bool, eq: bool, order: bool, unsafe_hash: bool, frozen: bool, config: Optional[type]) -> DataclassType: ...
def _validate_dataclass(cls: Type[DataclassT], v) -> DataclassT: ...
def create_model(__model_name: str, *, __config__: Type[pydantic.main.BaseConfig] = ..., __base__: Type[pydantic.main.BaseModel] = ..., __module__: Optional[str] = ..., __validators__: Dict[str, classmethod] = ..., **field_definitions) -> Type[pydantic.main.BaseModel]: ...
def dataclass(_cls: Optional[type] = ..., *, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., config: type = ...) -> Union[Callable[[type], DataclassType], DataclassType]: ...
def gather_all_validators(type_: type) -> Dict[str, classmethod]: ...
def setattr_validate_assignment(self: DataclassType, name: str, value) -> None: ...
def validate_model(model: Type[pydantic.main.BaseModel], input_data, cls = ...) -> Tuple[Any, Any, Any]: ...
