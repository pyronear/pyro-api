# (generated with --quick)

import collections
import decimal
import enum
import ipaddress
import pathlib
import pydantic.fields
import pydantic.main
import pydantic.types
import typing
from typing import Any, Callable, Generator, List, Pattern, Set, Tuple, Type, TypeVar, Union
import uuid

AnyOrderedDict = collections.OrderedDict

AnyCallable: Type[Callable]
BOOL_FALSE: Set[Union[int, str]]
BOOL_TRUE: Set[Union[int, str]]
BaseConfig: Type[pydantic.main.BaseConfig]
ConstrainedDecimal: Type[pydantic.types.ConstrainedDecimal]
ConstrainedFloat: Type[pydantic.types.ConstrainedFloat]
ConstrainedInt: Type[pydantic.types.ConstrainedInt]
ConstrainedNumber: Type[Union[pydantic.types.ConstrainedDecimal, pydantic.types.ConstrainedFloat, pydantic.types.ConstrainedInt]]
Decimal: Type[decimal.Decimal]
DecimalException: Type[decimal.DecimalException]
Enum: Type[enum.Enum]
ForwardRef: Any
Hashable: Type[typing.Hashable]
IPv4Address: Type[ipaddress.IPv4Address]
IPv4Interface: Type[ipaddress.IPv4Interface]
IPv4Network: Type[ipaddress.IPv4Network]
IPv6Address: Type[ipaddress.IPv6Address]
IPv6Interface: Type[ipaddress.IPv6Interface]
IPv6Network: Type[ipaddress.IPv6Network]
IntEnum: Type[enum.IntEnum]
ModelField: Type[pydantic.fields.ModelField]
Number: Type[Union[float, int, decimal.Decimal]]
OrderedDict: Type[collections.OrderedDict]
Path: Type[pathlib.Path]
StrBytes: Type[Union[bytes, str]]
UUID: Type[uuid.UUID]
_VALIDATORS: List[Tuple[type, list]]
date: Type[datetime.date]
datetime: Type[datetime.datetime]
errors: module
re: module
time: Type[datetime.time]
timedelta: Type[datetime.timedelta]

T = TypeVar('T')

class IfConfig:
    config_attr_names: Tuple[str, ...]
    validator: Callable
    def __init__(self, validator: Callable, *config_attr_names: str) -> None: ...
    def check(self, config: Type[pydantic.main.BaseConfig]) -> bool: ...

def all_literal_values(type_) -> Any: ...
def almost_equal_floats(value_1: float, value_2: float, *, delta: float = ...) -> bool: ...
def any_class_validator(v) -> Type[T]: ...
def anystr_length_validator(v: Union[bytes, str], config: pydantic.main.BaseConfig) -> Union[bytes, str]: ...
def anystr_strip_whitespace(v: Union[bytes, str]) -> Union[bytes, str]: ...
def bool_validator(v) -> bool: ...
def bytes_validator(v) -> bytes: ...
def callable_validator(v) -> Callable: ...
def constant_validator(v, field: pydantic.fields.ModelField) -> Any: ...
def constr_length_validator(v: Union[bytes, str], field: pydantic.fields.ModelField, config: pydantic.main.BaseConfig) -> Union[bytes, str]: ...
def constr_strip_whitespace(v: Union[bytes, str], field: pydantic.fields.ModelField, config: pydantic.main.BaseConfig) -> Union[bytes, str]: ...
def decimal_validator(v) -> decimal.Decimal: ...
def dict_validator(v) -> dict: ...
def display_as_type(v) -> str: ...
def enum_validator(v, field: pydantic.fields.ModelField, config: pydantic.main.BaseConfig) -> enum.Enum: ...
def find_validators(type_: type, config: Type[pydantic.main.BaseConfig]) -> Generator[Callable, None, None]: ...
def float_validator(v) -> float: ...
def frozenset_validator(v) -> frozenset: ...
def get_class(type_) -> Any: ...
def hashable_validator(v) -> typing.Hashable: ...
def int_validator(v) -> int: ...
def ip_v4_address_validator(v) -> ipaddress.IPv4Address: ...
def ip_v4_interface_validator(v) -> ipaddress.IPv4Interface: ...
def ip_v4_network_validator(v) -> ipaddress.IPv4Network: ...
def ip_v6_address_validator(v) -> ipaddress.IPv6Address: ...
def ip_v6_interface_validator(v) -> ipaddress.IPv6Interface: ...
def ip_v6_network_validator(v) -> ipaddress.IPv6Network: ...
def is_callable_type(type_) -> bool: ...
def is_literal_type(type_) -> bool: ...
def lenient_issubclass(cls, class_or_tuple: Union[type, Tuple[type, ...]]) -> bool: ...
def list_validator(v) -> list: ...
def make_arbitrary_type_validator(type_: Type[T]) -> Callable[[T], T]: ...
def make_class_validator(type_: Type[T]) -> Callable[[Any], Type[T]]: ...
def make_literal_validator(type_) -> Callable[[Any], Any]: ...
def number_multiple_validator(v: Union[float, decimal.Decimal], field: pydantic.fields.ModelField) -> Union[float, int, decimal.Decimal]: ...
def number_size_validator(v: Union[float, decimal.Decimal], field: pydantic.fields.ModelField) -> Union[float, int, decimal.Decimal]: ...
def ordered_dict_validator(v) -> collections.OrderedDict: ...
def parse_date(value: Union[bytes, float, str, datetime.date]) -> datetime.date: ...
def parse_datetime(value: Union[bytes, float, str, datetime.datetime]) -> datetime.datetime: ...
def parse_duration(value: Union[bytes, float, str]) -> datetime.timedelta: ...
def parse_time(value: Union[bytes, float, str, datetime.time]) -> datetime.time: ...
def path_exists_validator(v) -> pathlib.Path: ...
def path_validator(v) -> pathlib.Path: ...
def pattern_validator(v) -> Pattern[str]: ...
def sequence_like(v: type) -> bool: ...
def set_validator(v) -> set: ...
def str_validator(v) -> str: ...
def strict_float_validator(v) -> float: ...
def strict_int_validator(v) -> int: ...
def strict_str_validator(v) -> str: ...
def tuple_validator(v) -> tuple: ...
def uuid_validator(v, field: pydantic.fields.ModelField) -> uuid.UUID: ...
def validate_json(v, config: pydantic.main.BaseConfig) -> Any: ...
