# (generated with --quick)

import enum
import pydantic.class_validators
import pydantic.fields
import pydantic.main
from typing import Any, Dict, Optional, Set, Tuple, Type, Union

BaseConfig: Any
BaseModel: Any
Enum: Type[enum.Enum]
FieldInfo: Type[pydantic.fields.FieldInfo]
ModelField: Type[pydantic.fields.ModelField]
REF_PREFIX: str
UndefinedType: Type[pydantic.fields.UndefinedType]
Validator: Type[pydantic.class_validators.Validator]
create_model: Any
fastapi: module
functools: module
re: module

def create_cloned_field(field: pydantic.fields.ModelField, *, cloned_types: Optional[Dict[type, type]] = ...) -> pydantic.fields.ModelField: ...
def create_response_field(name: str, type_: type, class_validators: Optional[Dict[str, pydantic.class_validators.Validator]] = ..., default = ..., required: Union[bool, pydantic.fields.UndefinedType] = ..., model_config: type = ..., field_info: Optional[pydantic.fields.FieldInfo] = ..., alias: Optional[str] = ...) -> pydantic.fields.ModelField: ...
def deep_dict_update(main_dict: dict, update_dict: dict) -> None: ...
def generate_operation_id_for_path(*, name: str, path: str, method: str) -> str: ...
def get_model_definitions(*, flat_models: Set[type], model_name_map: Dict[type, str]) -> Dict[str, Any]: ...
def get_path_param_names(path: str) -> Set[str]: ...
def is_dataclass(obj) -> bool: ...
def lenient_issubclass(cls, class_or_tuple: Union[type, Tuple[type, ...]]) -> bool: ...
def model_process_schema(model: Type[Union[enum.Enum, pydantic.main.BaseModel]], *, by_alias: bool = ..., model_name_map: Dict[Type[Union[enum.Enum, pydantic.main.BaseModel]], str], ref_prefix: Optional[str] = ..., known_models: Set[Type[Union[enum.Enum, pydantic.main.BaseModel]]] = ...) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]: ...
