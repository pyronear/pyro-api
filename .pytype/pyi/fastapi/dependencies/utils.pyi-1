# (generated with --quick)

import contextlib
import fastapi.dependencies.models
import fastapi.params
import fastapi.security.base
import fastapi.security.oauth2
import fastapi.security.open_id_connect_url
import logging
import pydantic.error_wrappers
import pydantic.errors
import pydantic.fields
import starlette.background
import starlette.datastructures
import starlette.requests
import starlette.responses
import starlette.websockets
from typing import Any, Callable, Coroutine, Dict, Iterator, List, Mapping, Optional, Sequence, Set, Tuple, Type, TypeVar, Union

CacheKey = Tuple[Optional[Callable], Tuple[str, ...]]

AsyncExitStack: Any
BackgroundTasks: Type[starlette.background.BackgroundTasks]
BaseModel: Any
Dependant: Type[fastapi.dependencies.models.Dependant]
ErrorWrapper: Type[pydantic.error_wrappers.ErrorWrapper]
FieldInfo: Type[pydantic.fields.FieldInfo]
FormData: Type[starlette.datastructures.FormData]
ForwardRef: Any
HTTPConnection: Type[starlette.requests.HTTPConnection]
Headers: Type[starlette.datastructures.Headers]
MissingError: Type[pydantic.errors.MissingError]
ModelField: Type[pydantic.fields.ModelField]
OAuth2: Type[fastapi.security.oauth2.OAuth2]
OpenIdConnect: Type[fastapi.security.open_id_connect_url.OpenIdConnect]
QueryParams: Type[starlette.datastructures.QueryParams]
Request: Type[starlette.requests.Request]
Required: Any
Response: Type[starlette.responses.Response]
SHAPE_LIST: int
SHAPE_SEQUENCE: int
SHAPE_SET: int
SHAPE_SINGLETON: int
SHAPE_TUPLE: int
SHAPE_TUPLE_ELLIPSIS: int
SecurityBase: Type[fastapi.security.base.SecurityBase]
SecurityRequirement: Type[fastapi.dependencies.models.SecurityRequirement]
SecurityScopes: Type[fastapi.security.oauth2.SecurityScopes]
UploadFile: Type[starlette.datastructures.UploadFile]
WebSocket: Type[starlette.websockets.WebSocket]
async_contextmanager_dependencies_error: str
asynccontextmanager: Any
asyncio: module
contextmanager_in_threadpool: Any
create_model: Any
create_response_field: Any
get_path_param_names: Any
inspect: module
logger: logging.Logger
multipart_incorrect_install_error: str
multipart_not_installed_error: str
params: module
sequence_shape_to_type: Dict[int, Type[Union[list, set, tuple]]]
sequence_shapes: Set[int]
sequence_types: Tuple[Type[list], Type[set], Type[tuple]]

T = TypeVar('T')
_T = TypeVar('_T')

def _fake_asynccontextmanager(func: Callable) -> Callable: ...
def add_non_field_param_to_dependency(*, param: inspect.Parameter, dependant: fastapi.dependencies.models.Dependant) -> Optional[bool]: ...
def add_param_to_fields(*, field: pydantic.fields.ModelField, dependant: fastapi.dependencies.models.Dependant) -> None: ...
def check_dependency_contextmanagers() -> None: ...
def check_file_field(field: pydantic.fields.ModelField) -> None: ...
def contextmanager(func: Callable[..., Iterator[_T]]) -> Callable[..., contextlib._GeneratorContextManager[_T]]: ...
def deepcopy(x: _T, memo: Optional[Dict[int, _T]] = ..., _nil = ...) -> _T: ...
def evaluate_forwardref(type_, globalns, localns) -> Any: ...
def get_annotation_from_field_info(annotation, field_info: pydantic.fields.FieldInfo, field_name: str) -> type: ...
def get_body_field(*, dependant: fastapi.dependencies.models.Dependant, name: str) -> Optional[pydantic.fields.ModelField]: ...
def get_dependant(*, path: str, call: Callable, name: Optional[str] = ..., security_scopes: Optional[List[str]] = ..., use_cache: bool = ...) -> fastapi.dependencies.models.Dependant: ...
def get_flat_dependant(dependant: fastapi.dependencies.models.Dependant, *, skip_repeats: bool = ..., visited: Optional[List[Tuple[Optional[Callable], Tuple[str, ...]]]] = ...) -> fastapi.dependencies.models.Dependant: ...
def get_flat_params(dependant: fastapi.dependencies.models.Dependant) -> List[pydantic.fields.ModelField]: ...
def get_missing_field_error(loc: Tuple[str, ...]) -> pydantic.error_wrappers.ErrorWrapper: ...
def get_param_field(*, param: inspect.Parameter, param_name: str, default_field_info: Type[fastapi.params.Param] = ..., force_type: Optional[fastapi.params.ParamTypes] = ..., ignore_default: bool = ...) -> pydantic.fields.ModelField: ...
def get_param_sub_dependant(*, param: inspect.Parameter, path: str, security_scopes: Optional[List[str]] = ...) -> fastapi.dependencies.models.Dependant: ...
def get_parameterless_sub_dependant(*, depends: fastapi.params.Depends, path: str) -> fastapi.dependencies.models.Dependant: ...
def get_schema_compatible_field(*, field: pydantic.fields.ModelField) -> pydantic.fields.ModelField: ...
def get_sub_dependant(*, depends: fastapi.params.Depends, dependency: Callable, path: str, name: Optional[str] = ..., security_scopes: Optional[List[str]] = ...) -> fastapi.dependencies.models.Dependant: ...
def get_typed_annotation(param: inspect.Parameter, globalns: Dict[str, Any]) -> Any: ...
def get_typed_signature(call: Callable) -> inspect.Signature: ...
def is_async_gen_callable(call: Callable) -> bool: ...
def is_coroutine_callable(call: Callable) -> bool: ...
def is_gen_callable(call: Callable) -> bool: ...
def is_scalar_field(field: pydantic.fields.ModelField) -> bool: ...
def is_scalar_sequence_field(field: pydantic.fields.ModelField) -> bool: ...
def lenient_issubclass(cls, class_or_tuple: Union[type, Tuple[type, ...]]) -> bool: ...
def request_body_to_args(required_params: List[pydantic.fields.ModelField], received_body: Optional[Union[starlette.datastructures.FormData, Dict[str, Any]]]) -> Coroutine[Any, Any, Tuple[Dict[str, Any], List[pydantic.error_wrappers.ErrorWrapper]]]: ...
def request_params_to_args(required_params: Sequence[pydantic.fields.ModelField], received_params: Union[starlette.datastructures.Headers, starlette.datastructures.QueryParams, Mapping[str, Any]]) -> Tuple[Dict[str, Any], List[pydantic.error_wrappers.ErrorWrapper]]: ...
def run_in_threadpool(func: Callable[..., T], *args, **kwargs) -> coroutine: ...
def solve_dependencies(*, request: Union[starlette.requests.Request, starlette.websockets.WebSocket], dependant: fastapi.dependencies.models.Dependant, body: Optional[Union[starlette.datastructures.FormData, Dict[str, Any]]] = ..., background_tasks: Optional[starlette.background.BackgroundTasks] = ..., response: Optional[starlette.responses.Response] = ..., dependency_overrides_provider = ..., dependency_cache: Optional[Dict[Tuple[Callable, Tuple[str]], Any]] = ...) -> Coroutine[Any, Any, Tuple[Dict[str, Any], List[pydantic.error_wrappers.ErrorWrapper], Optional[starlette.background.BackgroundTasks], starlette.responses.Response, Dict[Tuple[Callable, Tuple[str]], Any]]]: ...
def solve_generator(*, call: Callable, stack, sub_values: Dict[str, Any]) -> coroutine: ...
