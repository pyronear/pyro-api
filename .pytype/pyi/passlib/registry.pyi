# (generated with --quick)

import passlib.exc
from typing import Any, Callable, FrozenSet, List, Optional, Pattern, Tuple, Type

ANY: str
BUILTIN: str
OS_CRYPT: str
PasslibWarning: Type[passlib.exc.PasslibWarning]
PasswordHash: Any
_UNSET: Any
__all__: List[str]
_forbidden_names: FrozenSet[str]
_handlers: dict
_locations: dict
_name_re: Pattern[str]
_proxy: _PasslibRegistryProxy
exc: module
get_supported_os_crypt_schemes: Callable
log: logging.Logger
logging: module
os_crypt_present: bool
os_crypt_schemes: List[str]
re: module
unicode_or_str: Tuple[Type[str]]

class _PasslibRegistryProxy:
    __doc__: str
    __package__: None
    def __dir__(self) -> list: ...
    def __getattr__(self, attr) -> Any: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, attr, value) -> None: ...

def ExpectedTypeError(value, expected, param) -> TypeError: ...
def _has_crypt_handler(name, loaded_only = ...) -> bool: ...
def _resolve(hasher, param = ...) -> Any: ...
def _unload_handler_name(name, locations = ...) -> None: ...
def _validate_handler_name(name) -> bool: ...
def get_crypt_handler(name, default = ...) -> Any: ...
def has_backend(hasher, backend = ..., safe = ...) -> Any: ...
def has_os_crypt_support(hasher) -> Any: ...
def is_crypt_handler(obj) -> bool: ...
def list_crypt_handlers(loaded_only = ...) -> list: ...
def memoize_single_value(func) -> Callable: ...
def register_crypt_handler(handler, force = ..., _attr = ...) -> None: ...
def register_crypt_handler_path(name, path) -> None: ...
@overload
def warn(message: Warning, category = ..., stacklevel: int = ..., source = ...) -> None: ...
@overload
def warn(message: str, category: Optional[Type[Warning]] = ..., stacklevel: int = ..., source = ...) -> None: ...
