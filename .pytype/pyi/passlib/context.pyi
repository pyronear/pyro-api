# (generated with --quick)

import __future__
import passlib.exc
import passlib.utils.decor
import random
from typing import Any, Callable, Dict, Generator, List, Optional, Set, Tuple, Type, TypeVar, Union

BASE64_CHARS: str
BytesIO: Any
NativeStringIO: Any
PY2: bool
PY3: bool
PasslibConfigWarning: Type[passlib.exc.PasslibConfigWarning]
SafeConfigParser: Any
_UNSET: Any
__all__: List[str]
_always_needs_update: staticmethod
_coerce_scheme_options: dict
_forbidden_scheme_options: Set[str]
_global_settings: Set[str]
_preamble: str
exc: module
irange: Type[range]
log: logging.Logger
logging: module
memoized_property: Type[passlib.utils.decor.memoized_property]
native_string_types: Tuple[Type[str]]
num_types: Tuple[Type[int], Type[float]]
re: module
rng: random.Random
threading: module
time: module
timer: Callable[[], float]
uh: module
unicode: Type[str]
unicode_or_bytes_types: Tuple[Type[str], Type[bytes]]
with_statement: __future__._Feature

_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_TCryptContext = TypeVar('_TCryptContext', bound=CryptContext)
_TCryptPolicy = TypeVar('_TCryptPolicy', bound=CryptPolicy)

class CryptContext:
    __doc__: str
    _config: Optional[_CryptConfig]
    _dummy_hash: Any
    _dummy_secret: str
    _get_record: Optional[Callable[[Any, Any], Any]]
    _identify_record: Optional[Callable]
    _strip_unused_context_kwds: Any
    context_kwds: Any
    encrypt: Any
    genconfig: Any
    genhash: Any
    harden_verify: None
    hash_needs_update: Any
    min_verify_time: int
    mvt_estimate_max_samples: int
    mvt_estimate_max_time: int
    mvt_estimate_min_samples: int
    mvt_estimate_resolution: float
    policy: CryptPolicy
    def __init__(self, schemes = ..., policy = ..., _autoload = ..., **kwds) -> None: ...
    def __repr__(self) -> str: ...
    def _get_or_identify_record(self, hash, scheme = ..., category = ...) -> Any: ...
    def _get_policy(self) -> CryptPolicy: ...
    def _get_unregistered_handlers(self) -> tuple: ...
    @classmethod
    def _norm_source(cls, source: _T0) -> Union[CryptContext, _T0]: ...
    @staticmethod
    def _parse_config_key(ckey) -> Tuple[Any, Any, Any]: ...
    @staticmethod
    def _parse_ini_stream(stream, section, filename) -> dict: ...
    @staticmethod
    def _render_config_key(key) -> Any: ...
    @staticmethod
    def _render_ini_value(key, value) -> Any: ...
    def _reset_dummy_verify(self) -> None: ...
    def _set_policy(self, policy) -> None: ...
    def _write_to_parser(self, parser, section) -> None: ...
    def copy(self: _TCryptContext, **kwds) -> _TCryptContext: ...
    def default_scheme(self, category = ..., resolve = ..., unconfigured = ...) -> Any: ...
    def disable(self, hash = ...) -> Any: ...
    def dummy_verify(self, elapsed = ...) -> bool: ...
    def enable(self, hash) -> Any: ...
    @classmethod
    def from_path(cls: Type[_TCryptContext], path, section = ..., encoding = ...) -> _TCryptContext: ...
    @classmethod
    def from_string(cls: Type[_TCryptContext], source, section = ..., encoding = ...) -> _TCryptContext: ...
    def handler(self, scheme = ..., category = ..., unconfigured = ...) -> Any: ...
    def hash(self, secret, scheme = ..., category = ..., **kwds) -> Any: ...
    def identify(self, hash, category = ..., resolve = ..., required = ..., unconfigured = ...) -> Any: ...
    def is_enabled(self, hash) -> bool: ...
    def load(self, source, update = ..., section = ..., encoding = ...) -> None: ...
    def load_path(self, path, update = ..., section = ..., encoding = ...) -> Any: ...
    def needs_update(self, hash, scheme = ..., category = ..., secret = ...) -> Any: ...
    def replace(self, **kwds) -> Any: ...
    def reset_min_verify_time(self) -> None: ...
    def schemes(self, resolve = ..., category = ..., unconfigured = ...) -> Any: ...
    def to_dict(self, resolve = ...) -> dict: ...
    def to_string(self, section = ...) -> Any: ...
    def update(self, *args, **kwds) -> None: ...
    def using(self, **kwds) -> Any: ...
    def verify(self, secret, hash, scheme = ..., category = ..., **kwds) -> Any: ...
    def verify_and_update(self, secret, hash, scheme = ..., category = ..., **kwds) -> Tuple[bool, Any]: ...

class CryptPolicy:
    __doc__: str
    _context: Any
    _stub_policy: Any
    def __init__(self, *args, **kwds) -> None: ...
    @classmethod
    def from_path(cls: Type[_TCryptPolicy], path, section = ..., encoding = ...) -> _TCryptPolicy: ...
    @classmethod
    def from_source(cls, source: _T0, _warn = ...) -> Union[CryptPolicy, _T0]: ...
    @classmethod
    def from_sources(cls, sources, _warn = ...) -> Any: ...
    @classmethod
    def from_string(cls: Type[_TCryptPolicy], source, section = ..., encoding = ...) -> _TCryptPolicy: ...
    def get_handler(self, name = ..., category = ..., required = ...) -> Any: ...
    def get_min_verify_time(self, category = ...) -> int: ...
    def get_options(self, name, category = ...) -> Any: ...
    def handler_is_deprecated(self, name, category = ...) -> Any: ...
    def has_schemes(self) -> bool: ...
    def iter_config(self, ini = ..., resolve = ...) -> Any: ...
    def iter_handlers(self) -> Any: ...
    def replace(self, *args, **kwds) -> Any: ...
    def schemes(self, resolve = ...) -> list: ...
    def to_dict(self, resolve = ...) -> Any: ...
    def to_file(self, stream, section = ...) -> None: ...
    def to_string(self, section = ..., encoding = ...) -> Any: ...

class LazyCryptContext(CryptContext):
    __doc__: str
    _lazy_kwds: Optional[Dict[str, Any]]
    def __getattribute__(self, attr) -> Any: ...
    def __init__(self, schemes = ..., **kwds) -> None: ...
    def _lazy_init(self) -> None: ...

class _CryptConfig:
    __doc__: str
    _context_options: Optional[Dict[Any, dict]]
    _default_schemes: Any
    _record_lists: Optional[Dict[nothing, nothing]]
    _records: Optional[Dict[Tuple[Any, Any], Any]]
    _scheme_options: Optional[Dict[Any, Dict[Any, dict]]]
    categories: Optional[tuple]
    context_kwds: Optional[set]
    disabled_record: Any
    handlers: Optional[tuple]
    schemes: Optional[tuple]
    def __init__(self, source) -> None: ...
    @staticmethod
    def _create_record(handler, category = ..., deprecated = ..., **settings) -> Any: ...
    def _get_record_list(self, category = ...) -> Any: ...
    def _get_record_options_with_flag(self, scheme, category) -> Tuple[Any, Any]: ...
    def _get_scheme_optionmap(self, scheme, category, default = ...) -> Any: ...
    def _init_default_schemes(self) -> None: ...
    def _init_options(self, source) -> None: ...
    def _init_records(self) -> None: ...
    def _init_scheme_list(self, data) -> None: ...
    def _norm_context_option(self, cat, key: _T1, value) -> Tuple[_T1, Any]: ...
    def _norm_scheme_option(self, key: _T0, value) -> Tuple[_T0, Any]: ...
    def default_scheme(self, category) -> Any: ...
    @staticmethod
    def expand_settings(handler) -> Any: ...
    def get_base_handler(self, scheme) -> Any: ...
    def get_context_option_with_flag(self, category, key) -> Tuple[Any, bool]: ...
    def get_context_optionmap(self, key, _default: _T1 = ...) -> Union[dict, _T1]: ...
    def get_record(self, scheme, category) -> Any: ...
    def get_scheme_options_with_flag(self, scheme, category) -> Tuple[Any, bool]: ...
    def identify_record(self, hash, category, required = ...) -> Any: ...
    def is_deprecated_with_flag(self, scheme, category) -> Tuple[Any, bool]: ...
    def iter_config(self, resolve = ...) -> Generator[Tuple[Tuple[Any, Any, Any], Any], Any, None]: ...

def ExpectedStringError(value, param) -> Any: ...
def ExpectedTypeError(value, expected, param) -> TypeError: ...
def _coerce_vary_rounds(value) -> Union[float, int]: ...
def _is_handler_registered(handler) -> bool: ...
def _validate_handler_name(name) -> bool: ...
def as_bool(value: _T0, none: _T1 = ..., param = ...) -> Union[bool, _T0, _T1]: ...
def deprecated_method(msg = ..., deprecated = ..., removed = ..., updoc = ..., replacement = ...) -> Any: ...
def get_crypt_handler(name, default = ...) -> Any: ...
def getrandstr(rng, charset, count) -> Any: ...
def iteritems(d) -> Any: ...
def splitcomma(source, sep = ...) -> Any: ...
def to_bytes(source, encoding = ..., param = ..., source_encoding = ...) -> Any: ...
def to_unicode(source, encoding = ..., param = ...) -> Any: ...
@overload
def warn(message: Warning, category = ..., stacklevel: int = ..., source = ...) -> None: ...
@overload
def warn(message: str, category: Optional[Type[Warning]] = ..., stacklevel: int = ..., source = ...) -> None: ...
