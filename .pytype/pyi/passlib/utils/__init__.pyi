# (generated with --quick)

import binascii
import codecs
import passlib.exc
import passlib.utils.binary
import passlib.utils.decor
import typing
from typing import Any, Callable, Generator, Iterator, List, NoReturn, Optional, Set, Tuple, Type, TypeVar, Union

AB64_CHARS: str
BASE64_CHARS: str
BCRYPT_CHARS: str
Base64Engine: Type[passlib.utils.binary.Base64Engine]
HASH64_CHARS: str
Iterable: Type[typing.Iterable]
JYTHON: bool
LazyBase64Engine: Type[passlib.utils.binary.LazyBase64Engine]
MAX_PASSWORD_SIZE: int
MissingBackendError: Type[passlib.exc.MissingBackendError]
PY3: bool
PYPY: bool
Sequence: Type[typing.Sequence]
_52charset: str
_ASCII_TEST_BYTES: bytes
_ASCII_TEST_UNICODE: str
_B80: int
_BEMPTY: bytes
_BNULL: bytes
_BinAsciiError: Type[binascii.Error]
_NULL: str
_U80: str
_UEMPTY: str
_UNULL: str
_USPACE: str
_VAR_ANY_SET: Set[inspect._ParameterKind]
_VAR_KEYWORD: inspect._ParameterKind
__all__: List[str]
_context_attrs: Tuple[str, str, str, str, str, str]
_crypt: Optional[Callable[..., str]]
_false_set: Set[str]
_handler_attrs: Tuple[str, str, str, str, str, str]
_invalid_prefixes: str
_none_set: Set[str]
_safe_crypt_lock: Any
_stringprep_missing_reason: str
_true_set: Set[str]
bcrypt64: passlib.utils.binary.LazyBase64Engine
classproperty: Type[passlib.utils.decor.classproperty]
crypt_accepts_bytes: bool
crypt_needs_lock: bool
generate_password: Any
h64: passlib.utils.binary.LazyBase64Engine
h64big: passlib.utils.binary.LazyBase64Engine
has_crypt: bool
has_urandom: bool
hybrid_method: Type[passlib.utils.decor.hybrid_method]
inspect: module
irange: Type[range]
itertools: module
join_byte_elems: Type[bytes]
join_byte_values: Type[bytes]
log: logging.Logger
logging: module
math: module
memoized_property: Type[passlib.utils.decor.memoized_property]
nullcontext: Callable
os: module
random: module
re: module
rng: random.Random
rounds_cost_values: List[str]
stringprep: Optional[module]
sys: module
sys_bits: int
threading: Optional[module]
tick: Callable[[], float]
time: module
timeit: module
timer: Callable[[], float]
to_hash_str: Any
types: module
unicode: Type[str]
unicode_or_bytes_types: Tuple[Type[str], Type[bytes]]
unicode_or_str: Tuple[Type[str]]
unicodedata: module
unix_crypt_schemes: List[str]

AnyStr = TypeVar('AnyStr', str, bytes)
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')

class SequenceMixin:
    __doc__: str
    def __eq__(self, other) -> Any: ...
    def __getitem__(self, idx) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __ne__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    def _as_tuple(self) -> NoReturn: ...

def ExpectedStringError(value, param) -> Any: ...
def ExpectedTypeError(value, expected, param) -> TypeError: ...
def _lookup_codec(encoding: str) -> codecs.CodecInfo: ...
def a2b_base64(__data: Union[bytes, str]) -> bytes: ...
def ab64_decode(data) -> Any: ...
def ab64_encode(data) -> Any: ...
def accepts_keyword(func, key) -> bool: ...
def add_doc(obj, doc) -> None: ...
def as_bool(value: _T0, none: _T1 = ..., param = ...) -> Union[bool, _T0, _T1]: ...
def b2a_base64(__data: bytes, *, newline: bool = ...) -> bytes: ...
def b64decode(s: Union[bytes, str], altchars: Optional[bytes] = ..., validate: bool = ...) -> bytes: ...
def b64encode(s: bytes, altchars: Optional[bytes] = ...) -> bytes: ...
def b64s_decode(data) -> bytes: ...
def b64s_encode(data) -> bytes: ...
def batch(source, size) -> Generator[Any, Any, None]: ...
def byte_elem_value(elem: _T0) -> _T0: ...
def bytes_to_int(value) -> int: ...
@overload
def consteq(a: AnyStr, b: AnyStr) -> bool: ...
@overload
def consteq(left, right) -> bool: ...
def deprecated_function(msg = ..., deprecated = ..., removed = ..., updoc = ..., replacement = ..., _is_method = ..., func_module = ...) -> Callable[[Any], Any]: ...
def deprecated_method(msg = ..., deprecated = ..., removed = ..., updoc = ..., replacement = ...) -> Any: ...
def genseed(value = ...) -> int: ...
def get_method_function(func) -> Any: ...
def getrandbytes(rng, count) -> bytes: ...
def getrandstr(rng, charset, count) -> Any: ...
def has_rounds_info(handler) -> bool: ...
def has_salt_info(handler) -> bool: ...
def hexlify(data: bytes, sep: Union[bytes, str] = ..., bytes_per_sep: int = ...) -> bytes: ...
@overload
def imap(function, *sequences: Iterable[nothing]) -> Iterator[nothing]: ...
@overload
def imap(function: Callable[..., _T], *sequences: Iterable) -> Iterator[_T]: ...
def int_to_bytes(value, count) -> Any: ...
def is_ascii_codec(codec) -> bool: ...
def is_ascii_safe(source) -> bool: ...
def is_crypt_context(obj) -> bool: ...
def is_crypt_handler(obj) -> bool: ...
def is_safe_crypt_input(value) -> bool: ...
def is_same_codec(left, right) -> bool: ...
def join_bytes(iterable: typing.Iterable[bytes]) -> bytes: ...
def join_unicode(iterable: typing.Iterable[str]) -> str: ...
def nextgetter(obj) -> Any: ...
def parse_version(source) -> Optional[tuple]: ...
def render_bytes(source, *args) -> Any: ...
def repeat_string(source, size) -> Any: ...
def right_pad_string(source, size, pad = ...) -> Any: ...
def safe_crypt(secret, hash) -> Any: ...
def saslprep(source, param = ...) -> str: ...
def splitcomma(source, sep = ...) -> Any: ...
def str_consteq(left, right) -> bool: ...
def suppress_cause(exc: _T0, cause = ...) -> _T0: ...
def test_crypt(secret, hash) -> Any: ...
def to_bytes(source, encoding = ..., param = ..., source_encoding = ...) -> Any: ...
def to_native_str(source, encoding = ..., param = ...) -> Any: ...
def to_unicode(source, encoding = ..., param = ...) -> Any: ...
def u(s: _T0) -> _T0: ...
def unhexlify(__hexstr: Union[bytes, str]) -> bytes: ...
def update_mixin_classes(target, add = ..., remove = ..., append = ..., before = ..., after = ..., dryrun = ...) -> None: ...
def update_wrapper(wrapper: Callable, wrapped: Callable, assigned: typing.Sequence[str] = ..., updated: typing.Sequence[str] = ...) -> Callable: ...
def utf8_repeat_string(source, size) -> Any: ...
def utf8_truncate(source, index) -> Any: ...
@overload
def warn(message: Warning, category = ..., stacklevel: int = ..., source = ...) -> None: ...
@overload
def warn(message: str, category: Optional[Type[Warning]] = ..., stacklevel: int = ..., source = ...) -> None: ...
def xor_bytes(left, right) -> Any: ...
