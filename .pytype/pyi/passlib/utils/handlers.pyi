# (generated with --quick)

import __future__
import passlib.exc
import passlib.utils.decor
import random
from typing import Any, Iterable, List, NoReturn, Optional, Tuple, Type, TypeVar, Union

ALL_BYTE_VALUES: bytes
B64_CHARS: str
BASE64_CHARS: str
H64_CHARS: str
HASH64_CHARS: str
HEX_CHARS: str
LC_HEX_CHARS: str
LOWER_HEX_CHARS: str
MAX_PASSWORD_SIZE: int
MissingBackendError: Type[passlib.exc.MissingBackendError]
PADDED_B64_CHARS: str
PADDED_BASE64_CHARS: str
PY2: bool
PasslibConfigWarning: Type[passlib.exc.PasslibConfigWarning]
PasslibHashWarning: Type[passlib.exc.PasslibHashWarning]
PasswordHash: Any
UC_HEX_CHARS: str
UPPER_HEX_CHARS: str
_UDOLLAR: str
_UZERO: str
__all__: List[str]
_backend_lock: threading._RLock
classproperty: Type[passlib.utils.decor.classproperty]
exc: module
ifc: module
inspect: module
int_types: Tuple[Type[int]]
irange: Type[range]
join_byte_values: Type[bytes]
log: logging.Logger
logging: module
math: module
native_string_types: Tuple[Type[str]]
rng: random.Random
threading: module
unicode: Type[str]
unicode_or_bytes_types: Tuple[Type[str], Type[bytes]]
with_statement: __future__._Feature

AnyStr = TypeVar('AnyStr', str, bytes)
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_TPrefixWrapper = TypeVar('_TPrefixWrapper', bound=PrefixWrapper)
_TStaticHandler = TypeVar('_TStaticHandler', bound=StaticHandler)

class BackendMixin(Any):
    _BackendMixin__backend: Any
    __doc__: str
    _no_backend_suggestion: None
    _pending_backend: Any
    _pending_dry_run: bool
    backends: None
    @classmethod
    def _get_backend_loader(cls, name) -> NoReturn: ...
    @classmethod
    def _get_backend_owner(cls) -> Type[BackendMixin]: ...
    @classmethod
    def _set_backend(cls, name, dryrun) -> None: ...
    @classmethod
    def _stub_requires_backend(cls) -> None: ...
    @classmethod
    def get_backend(cls) -> Any: ...
    @classmethod
    def has_backend(cls, name = ...) -> bool: ...
    @classmethod
    def set_backend(cls, name = ..., dryrun = ...) -> Any: ...

class GenericHandler(MinimalHandler):
    __doc__: str
    _always_parse_settings: Tuple[()]
    _checksum_is_bytes: bool
    _hash_regex: None
    _parsed_settings: Any
    _stub_checksum: Any
    _unparsed_settings: Tuple[str, str]
    _unsafe_settings: Tuple[str, str]
    checksum: Any
    checksum_chars: None
    checksum_size: None
    context_kwds: Tuple[()]
    genconfig: Any
    genhash: Any
    ident: None
    setting_kwds: None
    use_defaults: Any
    def __init__(self, checksum = ..., use_defaults = ..., **kwds) -> None: ...
    def _calc_checksum(self, secret) -> NoReturn: ...
    def _calc_needs_update(self, secret = ...) -> bool: ...
    def _norm_checksum(self, checksum, relaxed = ...) -> Any: ...
    @classmethod
    def bitsize(cls, **kwds) -> Any: ...
    @classmethod
    def from_string(cls, hash, **context) -> NoReturn: ...
    @classmethod
    def hash(cls, secret, **kwds) -> Any: ...
    @classmethod
    def identify(cls, hash) -> Any: ...
    @classmethod
    def needs_update(cls, hash, secret = ..., **kwds) -> Any: ...
    @classmethod
    def parsehash(cls, hash, checksum = ..., sanitize = ...) -> dict: ...
    def to_string(self) -> NoReturn: ...
    @classmethod
    def verify(cls, secret, hash, **context) -> bool: ...

class HasEncodingContext(GenericHandler):
    __doc__: str
    context_kwds: Tuple[str]
    default_encoding: str
    encoding: Any
    use_defaults: bool
    def __init__(self, encoding = ..., **kwds) -> None: ...

class HasManyBackends(BackendMixin, GenericHandler):
    __doc__: str
    _calc_checksum_backend: Any
    @classmethod
    def _HasManyBackends__load_legacy_backend(cls, name) -> bool: ...
    def _calc_checksum(self, secret) -> Any: ...
    @classmethod
    def _get_backend_loader(cls, name) -> Any: ...
    @classmethod
    def _set_calc_checksum_backend(cls, func) -> None: ...

class HasManyIdents(GenericHandler):
    __doc__: str
    default_ident: None
    ident: Any
    ident_aliases: None
    ident_values: None
    use_defaults: bool
    def __init__(self, ident = ..., **kwds) -> None: ...
    @classmethod
    def _norm_ident(cls, ident) -> Any: ...
    @classmethod
    def _parse_ident(cls, hash) -> Tuple[Any, Any]: ...
    @classmethod
    def identify(cls, hash) -> Any: ...
    @classmethod
    def using(cls, default_ident = ..., ident = ..., **kwds) -> Any: ...

class HasRawChecksum(GenericHandler):
    __doc__: str
    _checksum_is_bytes: bool
    checksum: Any
    use_defaults: Any

class HasRawSalt(HasSalt):
    __doc__: str
    _salt_is_bytes: bool
    _salt_unit: str
    salt: Any
    salt_chars: bytes
    use_defaults: bool
    @classmethod
    def _generate_salt(cls) -> bytes: ...

class HasRounds(GenericHandler):
    __doc__: str
    default_rounds: None
    max_desired_rounds: None
    max_rounds: None
    min_desired_rounds: None
    min_rounds: int
    rounds: Any
    rounds_cost: str
    use_defaults: bool
    using_rounds_kwds: Tuple[str, str, str, str, str, str]
    vary_rounds: None
    def __init__(self, rounds = ..., **kwds) -> None: ...
    def _calc_needs_update(self, **kwds) -> Any: ...
    @classmethod
    def _calc_vary_rounds_range(cls, default_rounds) -> Tuple[Any, Any]: ...
    @classmethod
    def _clip_to_desired_rounds(cls, rounds) -> Any: ...
    @classmethod
    def _generate_rounds(cls) -> Any: ...
    @classmethod
    def _norm_rounds(cls, rounds, relaxed = ..., param = ...) -> Any: ...
    def _parse_rounds(self, rounds) -> Any: ...
    @classmethod
    def bitsize(cls, rounds = ..., vary_rounds = ..., **kwds) -> Any: ...
    @classmethod
    def using(cls, min_desired_rounds = ..., max_desired_rounds = ..., default_rounds = ..., vary_rounds = ..., min_rounds = ..., max_rounds = ..., rounds = ..., **kwds) -> Any: ...

class HasSalt(GenericHandler):
    __doc__: str
    _salt_is_bytes: bool
    _salt_unit: str
    default_salt_chars: Any
    default_salt_size: Any
    max_salt_size: None
    min_salt_size: int
    salt: Any
    salt_chars: None
    use_defaults: bool
    def __init__(self, salt = ..., **kwds) -> None: ...
    @classmethod
    def _clip_to_valid_salt_size(cls, salt_size, param = ..., relaxed = ...) -> Any: ...
    @classmethod
    def _generate_salt(cls) -> Any: ...
    @classmethod
    def _norm_salt(cls, salt, relaxed = ...) -> Any: ...
    def _parse_salt(self, salt) -> Any: ...
    @staticmethod
    def _truncate_salt(salt, mx) -> Any: ...
    @classmethod
    def bitsize(cls, salt_size = ..., **kwds) -> Any: ...
    @classmethod
    def using(cls, default_salt_size = ..., salt_size = ..., salt = ..., **kwds) -> Any: ...

class HasUserContext(GenericHandler):
    __doc__: str
    context_kwds: Tuple[str]
    genhash: Any
    use_defaults: bool
    user: Any
    def __init__(self, user = ..., **kwds) -> None: ...
    @classmethod
    def hash(cls, secret, user = ..., **context) -> Any: ...
    @classmethod
    def verify(cls, secret, hash, user = ..., **context) -> Any: ...

class MinimalHandler(Any):
    __doc__: str
    _configured: bool
    @classmethod
    def using(cls, relaxed = ...) -> Any: ...

class ParallelismMixin(GenericHandler):
    __doc__: str
    parallelism: Any
    use_defaults: bool
    def __init__(self, parallelism = ..., **kwds) -> None: ...
    def _calc_needs_update(self, **kwds) -> Any: ...
    @classmethod
    def _norm_parallelism(cls, parallelism, relaxed = ...) -> Any: ...
    @classmethod
    def using(cls, parallelism = ..., **kwds) -> Any: ...

class PrefixWrapper:
    __doc__: Any
    _derived_from: Optional[PrefixWrapper]
    _ident: Any
    _ident_values: bool
    _proxy_attrs: Tuple[str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str]
    _using_clone_attrs: Tuple[()]
    _wrapped_handler: Any
    _wrapped_name: Any
    encrypt: Any
    genconfig: Any
    genhash: Any
    ident: Any
    ident_values: Any
    name: Any
    orig_prefix: Any
    prefix: Any
    wrapped: Any
    def __dir__(self) -> list: ...
    def __getattr__(self, attr) -> Any: ...
    def __init__(self, name, wrapped, prefix = ..., orig_prefix = ..., lazy = ..., doc = ..., ident = ...) -> None: ...
    def __repr__(self) -> str: ...
    def __setattr__(self, attr, value) -> None: ...
    def _get_wrapped(self) -> Any: ...
    def _set_wrapped(self, handler) -> None: ...
    def _unwrap_hash(self, hash) -> Any: ...
    def _wrap_hash(self, hash) -> Any: ...
    def hash(self, secret, **kwds) -> Any: ...
    def identify(self, hash) -> Any: ...
    def needs_update(self, hash, **kwds) -> Any: ...
    def using(self: _TPrefixWrapper, **kwds) -> _TPrefixWrapper: ...
    def verify(self, secret, hash, **kwds) -> Any: ...

class StaticHandler(GenericHandler):
    _StaticHandler__cc_compat_hack: None
    __doc__: str
    _hash_prefix: str
    checksum: Any
    setting_kwds: Tuple[()]
    use_defaults: Any
    def _calc_checksum(self, secret) -> NoReturn: ...
    @classmethod
    def _norm_hash(cls, hash: _T0) -> _T0: ...
    @classmethod
    def from_string(cls: Type[_TStaticHandler], hash, **context) -> _TStaticHandler: ...
    def to_string(self) -> str: ...

class SubclassBackendMixin(BackendMixin):
    __doc__: str
    _backend_mixin_map: None
    _backend_mixin_target: bool
    @classmethod
    def _get_backend_loader(cls, name) -> Any: ...
    @classmethod
    def _get_backend_owner(cls) -> NoReturn: ...
    @classmethod
    def _set_backend(cls, name, dryrun) -> None: ...

class TruncateMixin(MinimalHandler):
    __doc__: str
    truncate_error: bool
    truncate_verify_reject: bool
    @classmethod
    def _check_truncate_policy(cls, secret) -> None: ...
    @classmethod
    def using(cls, truncate_error = ..., **kwds) -> Any: ...

def _bitsize(count, chars) -> int: ...
def accepts_keyword(func, key) -> bool: ...
def as_bool(value: _T0, none: _T1 = ..., param = ...) -> Union[bool, _T0, _T1]: ...
@overload
def consteq(a: AnyStr, b: AnyStr) -> bool: ...
@overload
def consteq(left, right) -> bool: ...
def deprecated_method(msg = ..., deprecated = ..., removed = ..., updoc = ..., replacement = ...) -> Any: ...
def extract_settings_kwds(handler, kwds) -> dict: ...
def get_crypt_handler(name, default = ...) -> Any: ...
def getrandbytes(rng, count) -> bytes: ...
def getrandstr(rng, charset, count) -> Any: ...
def guess_app_stacklevel(start = ...) -> Any: ...
def is_crypt_handler(obj) -> bool: ...
def join_unicode(iterable: Iterable[str]) -> str: ...
def mask_value(value, show = ..., pct = ..., char = ...) -> Any: ...
def norm_integer(handler, value: _T1, min: _T2 = ..., max: _T3 = ..., param = ..., relaxed = ...) -> Union[_T1, _T2, _T3]: ...
def parse_int(source, base = ..., default: _T2 = ..., param = ..., handler = ...) -> Union[int, _T2]: ...
def parse_mc2(hash, prefix, sep = ..., handler = ...) -> Tuple[Any, Any]: ...
def parse_mc3(hash, prefix, sep = ..., rounds_base = ..., default_rounds: _T4 = ..., handler = ...) -> Tuple[Union[int, _T4], Any, Any]: ...
def render_mc2(ident, salt, checksum, sep = ...) -> str: ...
def render_mc3(ident, rounds, salt, checksum, sep = ..., rounds_base = ...) -> str: ...
def str_to_uascii(s: _T0) -> _T0: ...
def to_native_str(source, encoding = ..., param = ...) -> Any: ...
def to_unicode(source, encoding = ..., param = ...) -> Any: ...
def to_unicode_for_identify(hash) -> Any: ...
def u(s: _T0) -> _T0: ...
def uascii_to_str(s: _T0) -> _T0: ...
def update_mixin_classes(target, add = ..., remove = ..., append = ..., before = ..., after = ..., dryrun = ...) -> None: ...
def validate_default_value(handler, default, norm, param = ...) -> bool: ...
def validate_secret(secret) -> None: ...
@overload
def warn(message: Warning, category = ..., stacklevel: int = ..., source = ...) -> None: ...
@overload
def warn(message: str, category: Optional[Type[Warning]] = ..., stacklevel: int = ..., source = ...) -> None: ...
def warn_hash_settings_deprecation(handler, kwds) -> None: ...
