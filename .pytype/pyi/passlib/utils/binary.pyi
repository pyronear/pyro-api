# (generated with --quick)

import __future__
import binascii
import passlib.utils.decor
from typing import Any, Callable, Dict, Generator, Iterable, Iterator, List, Optional, Tuple, Type, TypeVar, Union

AB64_CHARS: str
ALL_BYTE_VALUES: bytes
BASE64_CHARS: str
BCRYPT_CHARS: str
B_EMPTY: bytes
B_EQUAL: bytes
B_NULL: bytes
HASH64_CHARS: str
HEX_CHARS: str
LOWER_HEX_CHARS: str
PADDED_BASE64_CHARS: str
PY3: bool
UPPER_HEX_CHARS: str
_BASE64_PAD1: bytes
_BASE64_PAD2: bytes
_BASE64_STRIP: bytes
_BinAsciiError: Type[binascii.Error]
_TRANSLATE_SOURCE: list
__all__: List[str]
_b32_decode_pad: bytes
_b32_translate: bytes
absolute_import: __future__._Feature
bcrypt64: LazyBase64Engine
division: __future__._Feature
exc: module
h64: LazyBase64Engine
h64big: LazyBase64Engine
irange: Type[range]
join_byte_elems: Type[bytes]
join_byte_values: Type[bytes]
log: logging.Logger
logging: module
memoized_property: Type[passlib.utils.decor.memoized_property]
print_function: __future__._Feature
unicode: Type[str]
unicode_or_bytes_types: Tuple[Type[str], Type[bytes]]

_T = TypeVar('_T')
_T0 = TypeVar('_T0')

class Base64Engine:
    __doc__: str
    _decode64: Optional[Callable]
    _decode_bytes: Optional[Callable[[Any, Any, Any], Any]]
    _encode64: Any
    _encode_bytes: Optional[Callable[[Any, Any, Any], Any]]
    _padinfo2: Any
    _padinfo3: Any
    big: Any
    bytemap: Any
    charmap: Any
    def _Base64Engine__make_padset(self, bits) -> frozenset: ...
    def __init__(self, charmap, big = ...) -> None: ...
    def _decode_bytes_big(self, next_value, chunks, tail) -> Generator[Any, Any, None]: ...
    def _decode_bytes_little(self, next_value, chunks, tail) -> Generator[Any, Any, None]: ...
    def _decode_int(self, source, bits) -> Any: ...
    def _encode_bytes_big(self, next_value, chunks, tail) -> Generator[Any, Any, None]: ...
    def _encode_bytes_little(self, next_value, chunks, tail) -> Generator[Any, Any, None]: ...
    def _encode_int(self, value, bits) -> bytes: ...
    def check_repair_unused(self, source: _T0) -> Tuple[bool, Any]: ...
    def decode_bytes(self, source) -> bytes: ...
    def decode_int12(self, source) -> Any: ...
    def decode_int24(self, source) -> Any: ...
    def decode_int30(self, source) -> Any: ...
    def decode_int6(self, source) -> Any: ...
    def decode_int64(self, source) -> Any: ...
    def decode_transposed_bytes(self, source, offsets) -> bytes: ...
    def encode_bytes(self, source) -> bytes: ...
    def encode_int12(self, value) -> bytes: ...
    def encode_int24(self, value) -> bytes: ...
    def encode_int30(self, value) -> Any: ...
    def encode_int6(self, value) -> Any: ...
    def encode_int64(self, value) -> Any: ...
    def encode_transposed_bytes(self, source, offsets) -> Any: ...
    def repair_unused(self, source) -> Any: ...

class LazyBase64Engine(Base64Engine):
    __doc__: str
    _decode64: Callable
    _decode_bytes: Any
    _encode64: Any
    _encode_bytes: Any
    _lazy_opts: Optional[Tuple[tuple, Dict[str, Any]]]
    big: bool
    bytemap: Any
    def __getattribute__(self, attr) -> Any: ...
    def __init__(self, *args, **kwds) -> None: ...
    def _lazy_init(self) -> None: ...

def _b32decode(s: Union[bytes, str], casefold: bool = ..., map01: Optional[bytes] = ...) -> bytes: ...
def _b32encode(s: bytes) -> bytes: ...
def a2b_base64(__data: Union[bytes, str]) -> bytes: ...
def ab64_decode(data) -> Any: ...
def ab64_encode(data) -> Any: ...
def b2a_base64(__data: bytes, *, newline: bool = ...) -> bytes: ...
def b32decode(source) -> bytes: ...
def b32encode(source) -> Any: ...
def b64decode(s: Union[bytes, str], altchars: Optional[bytes] = ..., validate: bool = ...) -> bytes: ...
def b64encode(s: bytes, altchars: Optional[bytes] = ...) -> bytes: ...
def b64s_decode(data) -> bytes: ...
def b64s_encode(data) -> bytes: ...
def bascii_to_str(s) -> Any: ...
def compile_byte_translation(mapping, source = ...) -> bytes: ...
@overload
def imap(function, *sequences: Iterable[nothing]) -> Iterator[nothing]: ...
@overload
def imap(function: Callable[..., _T], *sequences: Iterable) -> Iterator[_T]: ...
def iter_byte_chars(s) -> Any: ...
def nextgetter(obj) -> Any: ...
def suppress_cause(exc: _T0, cause = ...) -> _T0: ...
def u(s: _T0) -> _T0: ...
