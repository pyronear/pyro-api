# (generated with --quick)

import ecdsa.curves
import ecdsa.keys
import jose.backends.base
import jose.constants
import jose.exceptions
from typing import Any, Callable, Dict, Optional, Type, TypeVar, Union

ALGORITHMS: jose.constants.Algorithms
JWKError: Type[jose.exceptions.JWKError]
Key: Type[jose.backends.base.Key]
ecdsa: module
hashlib: module
six: module

_TECDSAECKey = TypeVar('_TECDSAECKey', bound=ECDSAECKey)

class ECDSAECKey(jose.backends.base.Key):
    CURVE_MAP: Dict[Callable[..., hashlib._Hash], ecdsa.curves.Curve]
    __doc__: str
    _algorithm: Any
    curve: Optional[ecdsa.curves.Curve]
    hash_alg: Optional[Callable[..., hashlib._Hash]]
    prepared_key: Any
    def SHA256(string: bytes = ...) -> hashlib._Hash: ...
    def SHA384(string: bytes = ...) -> hashlib._Hash: ...
    def SHA512(string: bytes = ...) -> hashlib._Hash: ...
    def __init__(self, key, algorithm) -> None: ...
    def _process_jwk(self, jwk_dict) -> Union[ecdsa.keys.SigningKey, ecdsa.keys.VerifyingKey]: ...
    def is_public(self) -> bool: ...
    def public_key(self: _TECDSAECKey) -> _TECDSAECKey: ...
    def sign(self, msg) -> Any: ...
    def to_dict(self) -> Dict[str, Any]: ...
    def to_pem(self) -> Any: ...
    def verify(self, msg, sig) -> Any: ...

def base64_to_long(data) -> Any: ...
def long_to_base64(data, size = ...) -> bytes: ...
