# (generated with --quick)

import click.core
import click.types
from typing import Any, Dict, Generator, Pattern, Type

Argument: Type[click.core.Argument]
COMPLETION_SCRIPT_BASH: str
COMPLETION_SCRIPT_FISH: str
COMPLETION_SCRIPT_ZSH: str
Choice: Type[click.types.Choice]
MultiCommand: Type[click.core.MultiCommand]
Option: Type[click.core.Option]
WORDBREAK: str
_completion_scripts: Dict[str, str]
_invalid_ident_char_re: Pattern[str]
abc: module
copy: module
os: module
re: module

def add_subcommand_completions(ctx, incomplete, completions_out) -> None: ...
def bashcomplete(cli, prog_name, complete_var, complete_instr) -> Any: ...
def do_complete(cli, prog_name, include_descriptions) -> bool: ...
def do_complete_fish(cli, prog_name) -> bool: ...
def echo(message = ..., file = ..., nl = ..., err = ..., color = ...) -> None: ...
def get_choices(cli, prog_name, args, incomplete) -> Any: ...
def get_completion_script(prog_name, complete_var, shell) -> str: ...
def get_user_autocompletions(ctx, args, incomplete, cmd_param) -> Any: ...
def get_visible_commands_starting_with(ctx, starts_with) -> Generator[Any, Any, None]: ...
def is_incomplete_argument(current_params, cmd_param) -> bool: ...
def is_incomplete_option(all_args, cmd_param) -> bool: ...
def resolve_ctx(cli, prog_name, args) -> Any: ...
def split_arg_string(string) -> list: ...
def start_of_option(param_str) -> Any: ...
