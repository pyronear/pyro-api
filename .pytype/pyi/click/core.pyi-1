# (generated with --quick)

import click.exceptions
import click.formatting
import click.parser
import click.types
import click.utils
import contextlib
from typing import Any, Callable, Dict, Iterator, List, NoReturn, Optional, Sequence, Tuple, Type, TypeVar, Union

Abort: Type[click.exceptions.Abort]
BOOL: click.types.BoolParamType
BadParameter: Type[click.exceptions.BadParameter]
ClickException: Type[click.exceptions.ClickException]
DEPRECATED_HELP_NOTICE: str
DEPRECATED_INVOKE_NOTICE: str
Exit: Type[click.exceptions.Exit]
HelpFormatter: Type[click.formatting.HelpFormatter]
IntRange: Type[click.types.IntRange]
MissingParameter: Type[click.exceptions.MissingParameter]
OptionParser: Type[click.parser.OptionParser]
PY2: bool
PacifyFlushWrapper: Type[click.utils.PacifyFlushWrapper]
SUBCOMMANDS_METAVAR: str
SUBCOMMAND_METAVAR: str
UsageError: Type[click.exceptions.UsageError]
_check_for_unicode_literals: Any
_missing: Any
_verify_python3_env: Any
augment_usage_errors: Callable[..., contextlib._GeneratorContextManager]
errno: module
inspect: module
os: module
string_types: Tuple[Type[str]]
sys: module

_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_TContext = TypeVar('_TContext', bound=Context)

class Argument(Parameter):
    __doc__: str
    autocompletion: None
    callback: None
    default: None
    envvar: None
    expose_value: bool
    human_readable_name: Any
    is_eager: bool
    metavar: None
    multiple: bool
    name: Any
    nargs: Any
    opts: Any
    param_type_name: str
    required: bool
    secondary_opts: Any
    type: Any
    def __init__(self, param_decls, required = ..., **attrs) -> None: ...
    def _parse_decls(self, decls, expose_value) -> Tuple[Any, list, List[nothing]]: ...
    def add_to_parser(self, parser, ctx) -> None: ...
    def get_error_hint(self, ctx) -> str: ...
    def get_usage_pieces(self, ctx) -> list: ...
    def make_metavar(self) -> Any: ...

class BaseCommand:
    __doc__: str
    allow_extra_args: bool
    allow_interspersed_args: bool
    context_settings: Any
    ignore_unknown_options: bool
    name: Any
    def __call__(self, *args, **kwargs) -> Any: ...
    def __init__(self, name, context_settings = ...) -> None: ...
    def __repr__(self) -> str: ...
    def get_help(self, ctx) -> NoReturn: ...
    def get_usage(self, ctx) -> NoReturn: ...
    def invoke(self, ctx) -> NoReturn: ...
    def main(self, args = ..., prog_name = ..., complete_var = ..., standalone_mode = ..., **extra) -> Any: ...
    def make_context(self, info_name, args, parent = ..., **extra) -> Context: ...
    def parse_args(self, ctx, args) -> NoReturn: ...

class Command(BaseCommand):
    __doc__: str
    add_help_option: Any
    callback: Any
    context_settings: Any
    deprecated: Any
    epilog: Any
    help: Any
    hidden: Any
    name: Any
    no_args_is_help: Any
    options_metavar: Any
    params: Any
    short_help: Any
    def __init__(self, name, context_settings = ..., callback = ..., params = ..., help = ..., epilog = ..., short_help = ..., options_metavar = ..., add_help_option = ..., no_args_is_help = ..., hidden = ..., deprecated = ...) -> None: ...
    def collect_usage_pieces(self, ctx) -> list: ...
    def format_epilog(self, ctx, formatter) -> None: ...
    def format_help(self, ctx, formatter) -> None: ...
    def format_help_text(self, ctx, formatter) -> None: ...
    def format_options(self, ctx, formatter) -> None: ...
    def format_usage(self, ctx, formatter) -> None: ...
    def get_help(self, ctx) -> Any: ...
    def get_help_option(self, ctx) -> Optional[Option]: ...
    def get_help_option_names(self, ctx) -> set: ...
    def get_params(self, ctx) -> Any: ...
    def get_short_help_str(self, limit = ...) -> Any: ...
    def get_usage(self, ctx) -> Any: ...
    def invoke(self, ctx) -> Any: ...
    def make_parser(self, ctx) -> click.parser.OptionParser: ...
    def parse_args(self, ctx, args) -> Any: ...

class CommandCollection(MultiCommand):
    __doc__: str
    add_help_option: bool
    callback: None
    chain: bool
    context_settings: Dict[nothing, nothing]
    deprecated: bool
    epilog: None
    help: None
    hidden: bool
    invoke_without_command: bool
    name: Any
    no_args_is_help: bool
    options_metavar: str
    params: List[nothing]
    result_callback: None
    short_help: None
    sources: Any
    subcommand_metavar: str
    def __init__(self, name = ..., sources = ..., **attrs) -> None: ...
    def add_source(self, multi_cmd) -> None: ...
    def get_command(self, ctx, cmd_name) -> Any: ...
    def list_commands(self, ctx) -> list: ...

class Context:
    __doc__: str
    _close_callbacks: list
    _depth: int
    _meta: Any
    allow_extra_args: Any
    allow_interspersed_args: Any
    args: List[nothing]
    auto_envvar_prefix: Any
    color: Any
    command: Any
    command_path: Any
    default_map: Any
    help_option_names: Any
    ignore_unknown_options: Any
    info_name: Any
    invoked_subcommand: None
    max_content_width: Any
    meta: Any
    obj: Any
    params: Dict[nothing, nothing]
    parent: Any
    protected_args: List[nothing]
    resilient_parsing: Any
    scope: Callable[..., contextlib._GeneratorContextManager]
    show_default: Any
    terminal_width: Any
    token_normalize_func: Any
    def __enter__(self: _TContext) -> _TContext: ...
    def __exit__(self, exc_type, exc_value, tb) -> None: ...
    def __init__(self, command, parent = ..., info_name = ..., obj = ..., auto_envvar_prefix = ..., default_map = ..., terminal_width = ..., max_content_width = ..., resilient_parsing = ..., allow_extra_args = ..., allow_interspersed_args = ..., ignore_unknown_options = ..., help_option_names = ..., token_normalize_func = ..., color = ..., show_default = ...) -> None: ...
    def abort(self) -> NoReturn: ...
    def call_on_close(self, f: _T0) -> _T0: ...
    def close(self) -> None: ...
    def ensure_object(self, object_type) -> Any: ...
    def exit(self, code = ...) -> NoReturn: ...
    def fail(self, message) -> NoReturn: ...
    def find_object(self, object_type) -> Any: ...
    def find_root(self) -> Any: ...
    def forward(*args, **kwargs) -> Any: ...
    def get_help(self) -> Any: ...
    def get_usage(self) -> Any: ...
    def invoke(*args, **kwargs) -> Any: ...
    def lookup_default(self, name) -> Any: ...
    def make_formatter(self) -> click.formatting.HelpFormatter: ...

class Group(MultiCommand):
    __doc__: str
    add_help_option: bool
    callback: None
    chain: bool
    commands: Any
    context_settings: Dict[nothing, nothing]
    deprecated: bool
    epilog: None
    help: None
    hidden: bool
    invoke_without_command: bool
    name: Any
    no_args_is_help: bool
    options_metavar: str
    params: List[nothing]
    result_callback: None
    short_help: None
    subcommand_metavar: str
    def __init__(self, name = ..., commands = ..., **attrs) -> None: ...
    def add_command(self, cmd, name = ...) -> None: ...
    def command(self, *args, **kwargs) -> Callable[[Any], Any]: ...
    def get_command(self, ctx, cmd_name) -> Any: ...
    def group(self, *args, **kwargs) -> Callable[[Any], Any]: ...
    def list_commands(self, ctx) -> list: ...

class MultiCommand(Command):
    __doc__: str
    add_help_option: bool
    allow_extra_args: bool
    allow_interspersed_args: bool
    callback: None
    chain: Any
    context_settings: Dict[nothing, nothing]
    deprecated: bool
    epilog: None
    help: None
    hidden: bool
    invoke_without_command: Any
    name: Any
    no_args_is_help: Any
    options_metavar: str
    params: List[nothing]
    result_callback: Any
    short_help: None
    subcommand_metavar: Any
    def __init__(self, name = ..., invoke_without_command = ..., no_args_is_help = ..., subcommand_metavar = ..., chain = ..., result_callback = ..., **attrs) -> None: ...
    def collect_usage_pieces(self, ctx) -> Any: ...
    def format_commands(self, ctx, formatter) -> None: ...
    def format_options(self, ctx, formatter) -> None: ...
    def get_command(self, ctx, cmd_name) -> NoReturn: ...
    def invoke(self, ctx) -> Any: ...
    def list_commands(self, ctx) -> List[nothing]: ...
    def parse_args(self, ctx, args) -> Any: ...
    def resolve_command(self, ctx, args) -> Tuple[Any, Any, Any]: ...
    def resultcallback(self, replace = ...) -> Callable[[Any], Any]: ...

class Option(Parameter):
    __doc__: str
    allow_from_autoenv: Any
    autocompletion: None
    callback: Optional[Callable[[Any, Any, Any], Any]]
    confirmation_prompt: Any
    count: Any
    default: Optional[int]
    envvar: None
    expose_value: bool
    flag_value: Any
    help: Any
    hidden: Any
    hide_input: Any
    is_bool_flag: bool
    is_eager: bool
    is_flag: Any
    metavar: None
    multiple: Any
    name: Any
    nargs: Any
    opts: Any
    param_type_name: str
    prompt: Any
    required: bool
    secondary_opts: Any
    show_choices: Any
    show_default: Any
    show_envvar: Any
    type: Any
    def __init__(self, param_decls = ..., show_default = ..., prompt = ..., confirmation_prompt = ..., hide_input = ..., is_flag = ..., flag_value = ..., multiple = ..., count = ..., allow_from_autoenv = ..., type = ..., help = ..., hidden = ..., show_choices = ..., show_envvar = ..., **attrs) -> None: ...
    def _parse_decls(self, decls, expose_value) -> Tuple[Any, list, list]: ...
    def add_to_parser(self, parser, ctx) -> None: ...
    def full_process_value(self, ctx, value) -> Any: ...
    def get_default(self, ctx) -> Any: ...
    def get_help_record(self, ctx) -> Optional[Tuple[str, Any]]: ...
    def prompt_for_value(self, ctx) -> Any: ...
    def resolve_envvar_value(self, ctx) -> Any: ...
    def value_from_envvar(self, ctx) -> Any: ...

class Parameter:
    __doc__: str
    autocompletion: Any
    callback: Any
    envvar: Any
    expose_value: Any
    human_readable_name: Any
    is_eager: Any
    metavar: Any
    multiple: bool
    name: Any
    nargs: Any
    opts: Any
    param_type_name: str
    required: Any
    secondary_opts: Any
    type: Any
    def __init__(self, param_decls = ..., type = ..., required = ..., default = ..., callback = ..., nargs = ..., metavar = ..., expose_value = ..., is_eager = ..., envvar = ..., autocompletion = ...) -> None: ...
    def __repr__(self) -> str: ...
    def add_to_parser(self, parser, ctx) -> None: ...
    def consume_value(self, ctx, opts) -> Any: ...
    def default(self) -> Any: ...
    def full_process_value(self, ctx, value) -> Any: ...
    def get_default(self, ctx) -> Any: ...
    def get_error_hint(self, ctx) -> str: ...
    def get_help_record(self, ctx) -> None: ...
    def get_usage_pieces(self, ctx) -> List[nothing]: ...
    def handle_parse_result(self, ctx, opts, args: _T2) -> Tuple[Any, _T2]: ...
    def make_metavar(self) -> Any: ...
    def process_value(self, ctx, value) -> Any: ...
    def resolve_envvar_value(self, ctx) -> Optional[str]: ...
    def type_cast_value(self, ctx, value) -> Any: ...
    def value_from_envvar(self, ctx) -> Any: ...
    def value_is_missing(self, value) -> bool: ...

def _bashcomplete(cmd, prog_name, complete_var = ...) -> None: ...
def _check_multicommand(base_command, cmd_name, cmd, register = ...) -> None: ...
def _maybe_show_deprecated_notice(cmd) -> None: ...
def batch(iterable, batch_size) -> list: ...
def confirm(text, default: _T1 = ..., abort = ..., prompt_suffix = ..., show_default = ..., err = ...) -> Union[bool, _T1]: ...
def contextmanager(func: Callable[..., Iterator[_T]]) -> Callable[..., contextlib._GeneratorContextManager[_T]]: ...
def convert_type(ty: _T0, default: _T1 = ...) -> Any: ...
def echo(message = ..., file = ..., nl = ..., err = ..., color = ...) -> None: ...
def fast_exit(code) -> NoReturn: ...
def get_os_args() -> Any: ...
def invoke_param_callback(callback, ctx, param, value) -> Any: ...
def isidentifier(x) -> Any: ...
def iter_params_for_processing(invocation_order, declaration_order) -> list: ...
def iteritems(x) -> Any: ...
def join_options(options) -> Tuple[str, bool]: ...
def make_default_short_help(help, max_length = ...) -> str: ...
def make_str(value) -> Any: ...
def pop_context() -> None: ...
def prompt(text, default = ..., hide_input = ..., confirmation_prompt = ..., type = ..., value_proc = ..., prompt_suffix = ..., show_default = ..., err = ..., show_choices = ...) -> Any: ...
def push_context(ctx) -> None: ...
@overload
def repeat(object: _T) -> Iterator[_T]: ...
@overload
def repeat(object: _T, times: int) -> Iterator[_T]: ...
def split_opt(opt: _T0) -> Tuple[Any, Any]: ...
def style(text, fg = ..., bg = ..., bold = ..., dim = ..., underline = ..., blink = ..., reverse = ..., reset = ...) -> str: ...
def update_wrapper(wrapper: Callable, wrapped: Callable, assigned: Sequence[str] = ..., updated: Sequence[str] = ...) -> Callable: ...
