# (generated with --quick)

import __future__
import packaging.version
from typing import Any, Callable, Dict, FrozenSet, Iterable, Iterator, List, Optional, Pattern, Tuple, Type, TypeVar, Union

CallableOperator = Callable[[Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]

LegacyVersion: Type[packaging.version.LegacyVersion]
ParsedVersion: Type[Union[packaging.version.LegacyVersion, packaging.version.Version]]
TYPE_CHECKING: bool
UnparsedVersion: Type[Union[str, packaging.version.LegacyVersion, packaging.version.Version]]
Version: Type[packaging.version.Version]
_prefix_regex: Pattern[str]
abc: module
absolute_import: __future__._Feature
division: __future__._Feature
functools: module
itertools: module
print_function: __future__._Feature
re: module
string_types: Tuple[Type[str]]

_TSpecifierSet = TypeVar('_TSpecifierSet', bound=SpecifierSet)

class BaseSpecifier(Any):
    prereleases: Optional[bool]
    @abstractmethod
    def __eq__(self, other: object) -> bool: ...
    @abstractmethod
    def __hash__(self) -> int: ...
    @abstractmethod
    def __ne__(self, other: object) -> bool: ...
    @abstractmethod
    def __str__(self) -> str: ...
    @abstractmethod
    def contains(self, item: str, prereleases: bool = ...) -> bool: ...
    @abstractmethod
    def filter(self, iterable: Iterable[Union[str, packaging.version.LegacyVersion, packaging.version.Version]], prereleases: bool = ...) -> Iterable[Union[str, packaging.version.LegacyVersion, packaging.version.Version]]: ...

class InvalidSpecifier(ValueError):
    __doc__: str

class LegacySpecifier(_IndividualSpecifier):
    _operators: Dict[str, str]
    _prereleases: Any
    _regex: Pattern[str]
    _regex_str: str
    _spec: Tuple[str, str]
    def _coerce_version(self, version: Union[str, packaging.version.LegacyVersion, packaging.version.Version]) -> packaging.version.LegacyVersion: ...
    def _compare_equal(self, prospective: packaging.version.LegacyVersion, spec: str) -> bool: ...
    def _compare_greater_than(self, prospective: packaging.version.LegacyVersion, spec: str) -> bool: ...
    def _compare_greater_than_equal(self, prospective: packaging.version.LegacyVersion, spec: str) -> bool: ...
    def _compare_less_than(self, prospective: packaging.version.LegacyVersion, spec: str) -> bool: ...
    def _compare_less_than_equal(self, prospective: packaging.version.LegacyVersion, spec: str) -> bool: ...
    def _compare_not_equal(self, prospective: packaging.version.LegacyVersion, spec: str) -> bool: ...

class Specifier(_IndividualSpecifier):
    _compare_compatible: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _compare_equal: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _compare_greater_than: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _compare_greater_than_equal: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _compare_less_than: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _compare_less_than_equal: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _compare_not_equal: Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]
    _operators: Dict[str, str]
    _prereleases: Any
    _regex: Pattern[str]
    _regex_str: str
    _spec: Tuple[str, str]
    prereleases: bool
    def _compare_arbitrary(self, prospective: packaging.version.Version, spec: str) -> bool: ...

class SpecifierSet(BaseSpecifier):
    _prereleases: Optional[bool]
    _specs: FrozenSet[Union[LegacySpecifier, Specifier]]
    prereleases: Optional[bool]
    def __and__(self: _TSpecifierSet, other: Union[str, _TSpecifierSet]) -> _TSpecifierSet: ...
    def __contains__(self, item: Union[str, packaging.version.LegacyVersion, packaging.version.Version]) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __init__(self, specifiers: str = ..., prereleases: bool = ...) -> None: ...
    def __iter__(self) -> Iterator[FrozenSet[_IndividualSpecifier]]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def contains(self, item: Union[str, packaging.version.LegacyVersion, packaging.version.Version], prereleases: bool = ...) -> bool: ...
    def filter(self, iterable, prereleases = ...) -> Iterable[Union[str, packaging.version.LegacyVersion, packaging.version.Version]]: ...

class _IndividualSpecifier(BaseSpecifier):
    _canonical_spec: Tuple[str, Union[str, packaging.version.Version]]
    _operators: Dict[str, str]
    _prereleases: Any
    _spec: Tuple[str, str]
    operator: str
    prereleases: Optional[bool]
    version: str
    def __contains__(self, item: str) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __init__(self, spec: str = ..., prereleases: bool = ...) -> None: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def _coerce_version(self, version: Union[str, packaging.version.LegacyVersion, packaging.version.Version]) -> Union[packaging.version.LegacyVersion, packaging.version.Version]: ...
    def _get_operator(self, op: str) -> Callable[[Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]: ...
    def contains(self, item: Union[str, packaging.version.LegacyVersion, packaging.version.Version], prereleases: bool = ...) -> bool: ...
    def filter(self, iterable: Iterable[Union[str, packaging.version.LegacyVersion, packaging.version.Version]], prereleases: bool = ...) -> Iterable[Union[str, packaging.version.LegacyVersion, packaging.version.Version]]: ...

def _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]: ...
def _require_version_compare(fn) -> Callable[[Specifier, Union[packaging.version.LegacyVersion, packaging.version.Version], str], bool]: ...
def _version_split(version: str) -> List[str]: ...
def canonicalize_version(_version: str) -> Union[str, packaging.version.Version]: ...
def parse(version: str) -> Union[packaging.version.LegacyVersion, packaging.version.Version]: ...
def with_metaclass(meta: type, *bases: Tuple[type, ...]) -> Any: ...
