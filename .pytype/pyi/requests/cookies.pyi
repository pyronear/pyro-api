# (generated with --quick)

import _dummy_threading
import http.cookies
import typing
from typing import Any, Generator, NoReturn, Optional, Sequence, Tuple, Type, TypeVar, Union
import urllib.parse

Morsel: Type[http.cookies.Morsel]
MutableMapping: Type[typing.MutableMapping]
calendar: module
cookielib: module
copy: module
threading: module
time: module

AnyStr = TypeVar('AnyStr', str, bytes)
_T1 = TypeVar('_T1')
_TRequestsCookieJar = TypeVar('_TRequestsCookieJar', bound=RequestsCookieJar)

class CookieConflictError(RuntimeError):
    __doc__: str

class MockRequest:
    __doc__: str
    _new_headers: dict
    _r: Any
    host: Any
    origin_req_host: Any
    type: Any
    unverifiable: Any
    def __init__(self, request) -> None: ...
    def add_header(self, key, val) -> NoReturn: ...
    def add_unredirected_header(self, name, value) -> None: ...
    def get_full_url(self) -> Any: ...
    def get_header(self, name, default = ...) -> Any: ...
    def get_host(self) -> Any: ...
    def get_new_headers(self) -> dict: ...
    def get_origin_req_host(self) -> Any: ...
    def get_type(self) -> Any: ...
    def has_header(self, name) -> bool: ...
    def is_unverifiable(self) -> bool: ...

class MockResponse:
    __doc__: str
    _headers: Any
    def __init__(self, headers) -> None: ...
    def getheaders(self, name) -> None: ...
    def info(self) -> Any: ...

class RequestsCookieJar(Any, typing.MutableMapping):
    __doc__: str
    _cookies_lock: Union[_dummy_threading._RLock, threading._RLock]
    def __contains__(self, name) -> Any: ...
    def __delitem__(self, name) -> None: ...
    def __getitem__(self, name) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __setitem__(self, name, value) -> None: ...
    def __setstate__(self, state) -> None: ...
    def _find(self, name, domain = ..., path = ...) -> Any: ...
    def _find_no_duplicates(self, name, domain = ..., path = ...) -> Any: ...
    def copy(self: _TRequestsCookieJar) -> _TRequestsCookieJar: ...
    def get(self, name, default = ..., domain = ..., path = ...) -> Any: ...
    def get_dict(self, domain = ..., path = ...) -> dict: ...
    def get_policy(self) -> Any: ...
    def items(self) -> list: ...
    def iteritems(self) -> Generator[Tuple[Any, Any], Any, None]: ...
    def iterkeys(self) -> Generator[Any, Any, None]: ...
    def itervalues(self) -> Generator[Any, Any, None]: ...
    def keys(self) -> list: ...
    def list_domains(self) -> list: ...
    def list_paths(self) -> list: ...
    def multiple_domains(self) -> bool: ...
    def set(self, name, value, **kwargs) -> Any: ...
    def set_cookie(self, cookie, *args, **kwargs) -> Any: ...
    def update(self, other) -> None: ...
    def values(self) -> list: ...

def _copy_cookie_jar(jar) -> Any: ...
def cookiejar_from_dict(cookie_dict, cookiejar: _T1 = ..., overwrite = ...) -> Union[RequestsCookieJar, _T1]: ...
def create_cookie(name, value, **kwargs) -> Any: ...
def extract_cookies_to_jar(jar, request, response) -> None: ...
def get_cookie_header(jar, request) -> Any: ...
def merge_cookies(cookiejar, cookies) -> Any: ...
def morsel_to_cookie(morsel) -> Any: ...
def remove_cookie_by_name(cookiejar, name, domain = ..., path = ...) -> None: ...
def to_native_string(string, encoding = ...) -> Any: ...
@overload
def urlparse(url: str, scheme: Optional[str] = ..., allow_fragments: bool = ...) -> urllib.parse.ParseResult: ...
@overload
def urlparse(url: Optional[bytes], scheme: Optional[bytes] = ..., allow_fragments: bool = ...) -> urllib.parse.ParseResultBytes: ...
def urlunparse(components: Union[Sequence[Optional[AnyStr]], Tuple[Optional[AnyStr], Optional[AnyStr], Optional[AnyStr], Optional[AnyStr], Optional[AnyStr], Optional[AnyStr]]]) -> AnyStr: ...
