# (generated with --quick)

import __builtin__
import collections
import requests.cookies
import requests.exceptions
import requests.structures
import typing
from typing import Any, Callable, Dict, FrozenSet, Generator, List, Optional, Pattern, Sequence, Tuple, Type, TypeVar, Union
import urllib.parse

CaseInsensitiveDict: Type[requests.structures.CaseInsensitiveDict]
DEFAULT_CA_BUNDLE_PATH: Any
DEFAULT_PORTS: Dict[__builtin__.str, int]
FileModeWarning: Type[requests.exceptions.FileModeWarning]
InvalidHeader: Type[requests.exceptions.InvalidHeader]
InvalidURL: Type[requests.exceptions.InvalidURL]
Mapping: Type[typing.Mapping]
NETRC_FILES: Tuple[__builtin__.str, __builtin__.str]
OrderedDict: Type[collections.OrderedDict]
UNRESERVED_SET: FrozenSet[__builtin__.str]
UnrewindableBodyError: Type[requests.exceptions.UnrewindableBodyError]
_CLEAN_HEADER_REGEX_BYTE: Pattern[__builtin__.bytes]
_CLEAN_HEADER_REGEX_STR: Pattern[__builtin__.str]
__version__: __builtin__.str
_null: __builtin__.bytes
_null2: __builtin__.bytes
_null3: __builtin__.bytes
basestring: Tuple[Type[__builtin__.str], Type[__builtin__.bytes]]
bytes: Type[__builtin__.bytes]
certs: module
codecs: module
contextlib: module
getproxies_environment: Any
integer_types: Tuple[Type[int]]
io: module
is_py3: bool
os: module
proxy_bypass_environment: Any
re: module
set_environ: Callable[..., contextlib._GeneratorContextManager]
socket: module
str: Type[__builtin__.str]
struct: module
sys: module
tempfile: module
warnings: module
zipfile: module

AnyStr = TypeVar('AnyStr', str, bytes)
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')

def _parse_content_type_header(header) -> Tuple[Any, dict]: ...
def _parse_list_header(s: __builtin__.str) -> List[__builtin__.str]: ...
def add_dict_to_cookiejar(cj: _T0, cookie_dict) -> Union[requests.cookies.RequestsCookieJar, _T0]: ...
def address_in_network(ip, net) -> Any: ...
def check_header_validity(header) -> None: ...
def cookiejar_from_dict(cookie_dict, cookiejar: _T1 = ..., overwrite = ...) -> Union[requests.cookies.RequestsCookieJar, _T1]: ...
def default_headers() -> requests.structures.CaseInsensitiveDict: ...
def default_user_agent(name = ...) -> __builtin__.str: ...
def dict_from_cookiejar(cj) -> dict: ...
def dict_to_sequence(d) -> Any: ...
def dotted_netmask(mask) -> __builtin__.str: ...
def extract_zipped_paths(path: _T0) -> Union[__builtin__.str, _T0]: ...
def from_key_val_list(value) -> Optional[collections.OrderedDict]: ...
def get_auth_from_url(url) -> Tuple[__builtin__.str, __builtin__.str]: ...
def get_encoding_from_headers(headers) -> Any: ...
def get_encodings_from_content(content) -> list: ...
def get_environ_proxies(url, no_proxy = ...) -> Dict[__builtin__.str, __builtin__.str]: ...
def get_netrc_auth(url, raise_errors = ...) -> Optional[Tuple[Optional[__builtin__.str], Optional[__builtin__.str]]]: ...
def get_unicode_from_response(r) -> Any: ...
def getproxies() -> Dict[__builtin__.str, __builtin__.str]: ...
def guess_filename(obj) -> Any: ...
def guess_json_utf(data) -> Optional[__builtin__.str]: ...
def is_ipv4_address(string_ip) -> bool: ...
def is_valid_cidr(string_network) -> bool: ...
def iter_slices(string, slice_length) -> Generator[Any, Any, None]: ...
def parse_dict_header(value) -> Dict[__builtin__.str, Any]: ...
def parse_header_links(value) -> List[Dict[__builtin__.str, __builtin__.str]]: ...
def parse_list_header(value) -> list: ...
def prepend_scheme_if_needed(url, new_scheme) -> Any: ...
def proxy_bypass(host) -> Any: ...
def proxy_bypass_registry(host) -> bool: ...
@overload
def quote(string: __builtin__.str, safe: Union[bytearray, __builtin__.bytes, memoryview, __builtin__.str] = ..., encoding: Optional[__builtin__.str] = ..., errors: Optional[__builtin__.str] = ...) -> __builtin__.str: ...
@overload
def quote(string: Union[bytearray, __builtin__.bytes, memoryview], safe: Union[bytearray, __builtin__.bytes, memoryview, __builtin__.str] = ...) -> __builtin__.str: ...
def requote_uri(uri) -> __builtin__.str: ...
def rewind_body(prepared_request) -> None: ...
def select_proxy(url, proxies) -> Any: ...
def should_bypass_proxies(url, no_proxy) -> bool: ...
def stream_decode_response_unicode(iterator, r) -> Generator[Any, Any, None]: ...
def super_len(o) -> Any: ...
def to_key_val_list(value) -> Optional[list]: ...
def to_native_string(string, encoding = ...) -> Any: ...
def unquote(string: __builtin__.str, encoding: __builtin__.str = ..., errors: __builtin__.str = ...) -> __builtin__.str: ...
def unquote_header_value(value, is_filename = ...) -> Any: ...
def unquote_unreserved(uri) -> __builtin__.str: ...
def urldefragauth(url) -> __builtin__.str: ...
@overload
def urlparse(url: __builtin__.str, scheme: Optional[__builtin__.str] = ..., allow_fragments: bool = ...) -> urllib.parse.ParseResult: ...
@overload
def urlparse(url: Optional[Union[bytearray, __builtin__.bytes, memoryview]], scheme: Optional[Union[bytearray, __builtin__.bytes, memoryview]] = ..., allow_fragments: bool = ...) -> urllib.parse.ParseResultBytes: ...
def urlunparse(components: Union[Sequence[Optional[AnyStr]], Tuple[Optional[AnyStr], Optional[AnyStr], Optional[AnyStr], Optional[AnyStr], Optional[AnyStr], Optional[AnyStr]]]) -> AnyStr: ...
