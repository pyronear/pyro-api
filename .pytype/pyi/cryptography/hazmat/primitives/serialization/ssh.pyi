# (generated with --quick)

import __future__
import cryptography.exceptions
import cryptography.hazmat.primitives.ciphers.base
import cryptography.hazmat.primitives.serialization.base
from typing import Any, Dict, NoReturn, Pattern, Tuple, Type, Union

Cipher: Type[cryptography.hazmat.primitives.ciphers.base.Cipher]
Encoding: Type[cryptography.hazmat.primitives.serialization.base.Encoding]
NoEncryption: Any
PrivateFormat: Type[cryptography.hazmat.primitives.serialization.base.PrivateFormat]
PublicFormat: Type[cryptography.hazmat.primitives.serialization.base.PublicFormat]
UnsupportedAlgorithm: Type[cryptography.exceptions.UnsupportedAlgorithm]
_BCRYPT: bytes
_CERT_SUFFIX: bytes
_DEFAULT_CIPHER: bytes
_DEFAULT_ROUNDS: int
_ECDSA_KEY_TYPE: Dict[str, bytes]
_ECDSA_NISTP256: bytes
_ECDSA_NISTP384: bytes
_ECDSA_NISTP521: bytes
_KEY_FORMATS: Dict[bytes, Union[_SSHFormatDSA, _SSHFormatECDSA, _SSHFormatEd25519, _SSHFormatRSA]]
_MAX_PASSWORD: int
_NONE: bytes
_PADDING: memoryview
_PEM_RC: Pattern[bytes]
_SK_END: bytes
_SK_MAGIC: bytes
_SK_START: bytes
_SSH_CIPHERS: Dict[bytes, Tuple[Any, int, Any, int]]
_SSH_DSA: bytes
_SSH_ED25519: bytes
_SSH_PUBKEY_RC: Pattern[bytes]
_SSH_RSA: bytes
_U32: struct.Struct
_U64: struct.Struct
_bcrypt_supported: bool
absolute_import: __future__._Feature
algorithms: module
binascii: module
division: __future__._Feature
dsa: module
ec: module
ed25519: module
modes: module
os: module
print_function: __future__._Feature
re: module
rsa: module
six: module
struct: module
utils: module

class _FragList:
    __doc__: str
    flist: list
    def __init__(self, init = ...) -> None: ...
    def put_mpint(self, val) -> None: ...
    def put_raw(self, val) -> None: ...
    def put_sshstr(self, val) -> None: ...
    def put_u32(self, val) -> None: ...
    def render(self, dstbuf, pos = ...) -> Any: ...
    def size(self) -> int: ...
    def tobytes(self) -> bytes: ...

class _SSHFormatDSA:
    __doc__: str
    def _validate(self, public_numbers) -> None: ...
    def encode_private(self, private_key, f_priv) -> None: ...
    def encode_public(self, public_key, f_pub) -> None: ...
    def get_public(self, data) -> Tuple[Tuple[Any, Any, Any, Any], Any]: ...
    def load_private(self, data, pubfields, backend) -> Tuple[Any, Any]: ...
    def load_public(self, key_type, data, backend) -> Tuple[Any, Any]: ...

class _SSHFormatECDSA:
    __doc__: str
    curve: Any
    ssh_curve_name: Any
    def __init__(self, ssh_curve_name, curve) -> None: ...
    def encode_private(self, private_key, f_priv) -> None: ...
    def encode_public(self, public_key, f_pub) -> None: ...
    def get_public(self, data) -> Tuple[Tuple[Any, Any], Any]: ...
    def load_private(self, data, pubfields, backend) -> Tuple[Any, Any]: ...
    def load_public(self, key_type, data, backend) -> Tuple[Any, Any]: ...

class _SSHFormatEd25519:
    __doc__: str
    def encode_private(self, private_key, f_priv) -> None: ...
    def encode_public(self, public_key, f_pub) -> None: ...
    def get_public(self, data) -> Tuple[Tuple[Any], Any]: ...
    def load_private(self, data, pubfields, backend) -> Tuple[Any, Any]: ...
    def load_public(self, key_type, data, backend) -> Tuple[Any, Any]: ...

class _SSHFormatRSA:
    __doc__: str
    def encode_private(self, private_key, f_priv) -> None: ...
    def encode_public(self, public_key, f_pub) -> None: ...
    def get_public(self, data) -> Tuple[Tuple[Any, Any], Any]: ...
    def load_private(self, data, pubfields, backend) -> Tuple[Any, Any]: ...
    def load_public(self, key_type, data, backend) -> Tuple[Any, Any]: ...

def _base64_encode(s: bytes) -> bytes: ...
def _bcrypt_kdf(*args, **kwargs) -> NoReturn: ...
def _check_block_size(data, block_len) -> None: ...
def _check_empty(data) -> None: ...
def _ecdsa_key_type(public_key) -> bytes: ...
def _get_backend(backend) -> Any: ...
def _get_mpint(data) -> Tuple[int, Any]: ...
def _get_sshstr(data) -> Tuple[Any, Any]: ...
def _get_u32(data) -> Tuple[Any, Any]: ...
def _get_u64(data) -> Tuple[Any, Any]: ...
def _init_cipher(ciphername, password, salt, rounds, backend) -> cryptography.hazmat.primitives.ciphers.base.Cipher: ...
def _lookup_kformat(key_type) -> Union[_SSHFormatDSA, _SSHFormatECDSA, _SSHFormatEd25519, _SSHFormatRSA]: ...
def _ssh_pem_encode(data, prefix = ..., suffix = ...) -> bytes: ...
def _to_mpint(val) -> Any: ...
def load_ssh_private_key(data, password, backend = ...) -> Any: ...
def load_ssh_public_key(data, backend = ...) -> Any: ...
def serialize_ssh_private_key(private_key, password = ...) -> Any: ...
def serialize_ssh_public_key(public_key) -> bytes: ...
