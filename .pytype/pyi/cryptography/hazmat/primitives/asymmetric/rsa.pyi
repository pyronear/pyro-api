# (generated with --quick)

import __future__
import cryptography.exceptions
import cryptography.hazmat.backends.interfaces
import numbers
from typing import Any, Tuple, Type, Union

RSAPublicKeyWithSerialization = RSAPublicKey

RSABackend: Type[cryptography.hazmat.backends.interfaces.RSABackend]
UnsupportedAlgorithm: Type[cryptography.exceptions.UnsupportedAlgorithm]
_MAX_RECOVERY_ATTEMPTS: int
_Reasons: Type[cryptography.exceptions._Reasons]
abc: module
absolute_import: __future__._Feature
division: __future__._Feature
print_function: __future__._Feature
six: module
utils: module

class RSAPrivateKey(metaclass=abc.ABCMeta):
    key_size: Any
    @abstractmethod
    def decrypt(self, ciphertext, padding) -> Any: ...
    @abstractmethod
    def public_key(self) -> Any: ...
    @abstractmethod
    def sign(self, data, padding, algorithm) -> Any: ...
    @abstractmethod
    def signer(self, padding, algorithm) -> Any: ...

class RSAPrivateKeyWithSerialization(RSAPrivateKey):
    @abstractmethod
    def private_bytes(self, encoding, format, encryption_algorithm) -> Any: ...
    @abstractmethod
    def private_numbers(self) -> Any: ...

class RSAPrivateNumbers:
    _d: Any
    _dmp1: Any
    _dmq1: Any
    _iqmp: Any
    _p: Any
    _public_numbers: Any
    _q: Any
    d: Any
    dmp1: Any
    dmq1: Any
    iqmp: Any
    p: Any
    public_numbers: Any
    q: Any
    def __eq__(self, other) -> Any: ...
    def __hash__(self) -> int: ...
    def __init__(self, p, q, d, dmp1, dmq1, iqmp, public_numbers) -> None: ...
    def __ne__(self, other) -> bool: ...
    def private_key(self, backend = ...) -> Any: ...

class RSAPublicKey(metaclass=abc.ABCMeta):
    key_size: Any
    @abstractmethod
    def encrypt(self, plaintext, padding) -> Any: ...
    @abstractmethod
    def public_bytes(self, encoding, format) -> Any: ...
    @abstractmethod
    def public_numbers(self) -> Any: ...
    @abstractmethod
    def verifier(self, signature, padding, algorithm) -> Any: ...
    @abstractmethod
    def verify(self, signature, data, padding, algorithm) -> Any: ...

class RSAPublicNumbers:
    _e: Any
    _n: Any
    e: Any
    n: Any
    def __eq__(self, other) -> Any: ...
    def __hash__(self) -> int: ...
    def __init__(self, e, n) -> None: ...
    def __ne__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    def public_key(self, backend = ...) -> Any: ...

def _check_private_key_components(p, q, private_exponent, dmp1, dmq1, iqmp, public_exponent, modulus) -> None: ...
def _check_public_key_components(e, n) -> None: ...
def _get_backend(backend) -> Any: ...
def _modinv(e, m) -> Any: ...
def _verify_rsa_parameters(public_exponent, key_size) -> None: ...
@overload
def gcd(__x: int, __y: int) -> int: ...
@overload
def gcd(a: int, b: int) -> int: ...
@overload
def gcd(a: numbers.Integral, b: int) -> numbers.Integral: ...
@overload
def gcd(a: Union[int, numbers.Integral], b: numbers.Integral) -> numbers.Integral: ...
def generate_private_key(public_exponent, key_size, backend = ...) -> Any: ...
def rsa_crt_dmp1(private_exponent, p) -> Any: ...
def rsa_crt_dmq1(private_exponent, q) -> Any: ...
def rsa_crt_iqmp(p, q) -> Any: ...
def rsa_recover_prime_factors(n, e, d) -> Tuple[Any, Any]: ...
