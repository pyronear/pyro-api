# (generated with --quick)

from typing import Any, NoReturn, Tuple, Type, TypeVar

BOOLEANTYPE: None
INDEXABLE: None
INTEGERTYPE: None
MATCHTYPE: None
NULLTYPE: None
STRINGTYPE: None
SchemaEventTarget: Any
Visitable: Any
VisitableType: Any
_resolve_value_to_type: None
exc: Any
operators: Any
util: module

_T0 = TypeVar('_T0')
_TNativeForEmulated = TypeVar('_TNativeForEmulated', bound=NativeForEmulated)
_TTypeDecorator = TypeVar('_TTypeDecorator', bound=TypeDecorator)
_TUserDefinedType = TypeVar('_TUserDefinedType', bound=UserDefinedType)
_TVariant = TypeVar('_TVariant', bound=Variant)

class Emulated:
    __doc__: str
    def adapt(self, impltype, **kw) -> Any: ...
    def adapt_to_emulated(self, impltype, **kw) -> Any: ...

class NativeForEmulated:
    __doc__: str
    @classmethod
    def adapt_emulated_to_native(cls: Type[_TNativeForEmulated], impl, **kw) -> _TNativeForEmulated: ...

class TypeDecorator(Any, TypeEngine):
    Comparator: type
    __doc__: str
    __visit_name__: str
    _has_bind_expression: Any
    _has_bind_processor: Any
    _has_column_expression: Any
    _has_literal_processor: Any
    _has_result_processor: Any
    _type_affinity: Any
    coerce_to_is_types: Tuple[Any]
    comparator_factory: Any
    impl: Any
    sort_key_function: Any
    def __getattr__(self, key) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __repr__(self) -> Any: ...
    def _gen_dialect_impl(self, dialect) -> Any: ...
    def _set_parent(self, column) -> None: ...
    def _set_parent_with_dispatch(self, parent) -> None: ...
    def _unwrapped_dialect_impl(self, dialect) -> Any: ...
    def bind_expression(self, bindparam) -> Any: ...
    def bind_processor(self, dialect) -> Any: ...
    def coerce_compared_value(self: _TTypeDecorator, op, value) -> _TTypeDecorator: ...
    def column_expression(self, column) -> Any: ...
    def compare_values(self, x, y) -> Any: ...
    def copy(self, **kw) -> Any: ...
    def get_dbapi_type(self, dbapi) -> Any: ...
    def literal_processor(self, dialect) -> Any: ...
    def load_dialect_impl(self, dialect) -> Any: ...
    def process_bind_param(self, value, dialect) -> NoReturn: ...
    def process_literal_param(self, value, dialect) -> NoReturn: ...
    def process_result_value(self, value, dialect) -> NoReturn: ...
    def result_processor(self, dialect, coltype) -> Any: ...
    def type_engine(self, dialect) -> Any: ...

class TypeEngine(Any):
    Comparator: type
    __doc__: str
    _default_dialect: Any
    _has_bind_expression: Any
    _has_column_expression: Any
    _isnull: bool
    _sqla_type: bool
    _type_affinity: Any
    comparator_factory: type
    hashable: bool
    should_evaluate_none: bool
    sort_key_function: None
    def __repr__(self) -> Any: ...
    def __str__(self) -> Any: ...
    def _cached_bind_processor(self, dialect) -> Any: ...
    def _cached_custom_processor(self, dialect, key, fn) -> Any: ...
    def _cached_literal_processor(self, dialect) -> Any: ...
    def _cached_result_processor(self, dialect, coltype) -> Any: ...
    def _compare_type_affinity(self, other) -> bool: ...
    def _dialect_info(self, dialect) -> Any: ...
    def _gen_dialect_impl(self, dialect) -> Any: ...
    @staticmethod
    def _to_instance(cls_or_self) -> Any: ...
    def _unwrapped_dialect_impl(self, dialect) -> Any: ...
    def adapt(self, cls, **kw) -> Any: ...
    def bind_expression(self, bindvalue) -> None: ...
    def bind_processor(self, dialect) -> None: ...
    def coerce_compared_value(self, op, value) -> Any: ...
    def column_expression(self, colexpr) -> None: ...
    def compare_against_backend(self, dialect, conn_type) -> None: ...
    def compare_values(self, x, y) -> Any: ...
    def compile(self, dialect = ...) -> Any: ...
    def copy(self, **kw) -> Any: ...
    def copy_value(self, value: _T0) -> _T0: ...
    def dialect_impl(self, dialect) -> Any: ...
    def evaluates_none(self) -> Any: ...
    def get_dbapi_type(self, dbapi) -> None: ...
    def literal_processor(self, dialect) -> None: ...
    def result_processor(self, dialect, coltype) -> None: ...
    def with_variant(self, type_, dialect_name) -> Variant: ...

class UserDefinedType(Any):
    Comparator: type
    __doc__: str
    __visit_name__: str
    comparator_factory: type
    ensure_kwarg: str
    def coerce_compared_value(self: _TUserDefinedType, op, value) -> _TUserDefinedType: ...

class Variant(TypeDecorator):
    __doc__: str
    comparator_factory: Any
    impl: Any
    mapping: Any
    def __init__(self, base, mapping) -> None: ...
    def _set_parent(self, column) -> None: ...
    def _set_parent_with_dispatch(self, parent) -> None: ...
    def coerce_compared_value(self, operator, value) -> Any: ...
    def load_dialect_impl(self, dialect) -> Any: ...
    def with_variant(self: _TVariant, type_, dialect_name) -> _TVariant: ...

class VisitableCheckKWArg(Any, Any): ...

def _reconstitute_comparator(expression) -> Any: ...
def adapt_type(typeobj, colspecs) -> Any: ...
def to_instance(typeobj, *arg, **kw) -> Any: ...
