# (generated with --quick)

from typing import Any, Callable, Container, Dict, Mapping, NoReturn, Sequence, Tuple, TypeVar, Union

_PRECEDENCE: dict
_asbool: Any
_associative: set
_booleans: Tuple[Callable[[Any], Any], Callable[[Any], Any], Callable[[Any], Any], Callable[[Any, Any], Any], Callable[[Any, Any], Any]]
_commutative: set
_comparison: set
_largest: Any
_mirror: Dict[Callable[[Any, Any], Any], Callable[[Any, Any], Any]]
_natural_self_precedent: set
_smallest: Any
div: Any
util: module

_K = TypeVar('_K')
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_V = TypeVar('_V')

class ColumnOperators(Operators):
    __slots__ = []
    __doc__: str
    timetuple: None
    def __add__(self, other) -> Any: ...
    def __contains__(self, other) -> Any: ...
    def __div__(self, other) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __hash__(self: object) -> int: ...
    def __le__(self, other) -> Any: ...
    def __lshift__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __mod__(self, other) -> Any: ...
    def __mul__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __neg__(self) -> Any: ...
    def __radd__(self, other) -> Any: ...
    def __rdiv__(self, other) -> Any: ...
    def __rmod__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rshift__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __sub__(self, other) -> Any: ...
    def __truediv__(self, other) -> Any: ...
    def all_(self) -> Any: ...
    def any_(self) -> Any: ...
    def asc(self) -> Any: ...
    def between(self, cleft, cright, symmetric = ...) -> Any: ...
    def collate(self, collation) -> Any: ...
    def concat(self, other) -> Any: ...
    def contains(self, other, **kwargs) -> Any: ...
    def desc(self) -> Any: ...
    def distinct(self) -> Any: ...
    def endswith(self, other, **kwargs) -> Any: ...
    def ilike(self, other, escape = ...) -> Any: ...
    def in_(self, other) -> Any: ...
    def is_(self, other) -> Any: ...
    def is_distinct_from(self, other) -> Any: ...
    def isnot(self, other) -> Any: ...
    def isnot_distinct_from(self, other) -> Any: ...
    def like(self, other, escape = ...) -> Any: ...
    def match(self, other, **kwargs) -> Any: ...
    def notilike(self, other, escape = ...) -> Any: ...
    def notin_(self, other) -> Any: ...
    def notlike(self, other, escape = ...) -> Any: ...
    def nullsfirst(self) -> Any: ...
    def nullslast(self) -> Any: ...
    def startswith(self, other, **kwargs) -> Any: ...

class Operators:
    __slots__ = []
    __doc__: str
    def __and__(self, other) -> Any: ...
    def __invert__(self) -> Any: ...
    def __or__(self, other) -> Any: ...
    def bool_op(self, opstring, precedence = ...) -> Any: ...
    def op(self, opstring, precedence = ..., is_comparison = ..., return_type = ...) -> Callable[[Any], Any]: ...
    def operate(self, op, *other, **kwargs) -> NoReturn: ...
    def reverse_operate(self, op, other, **kwargs) -> NoReturn: ...

class custom_op:
    __doc__: str
    eager_grouping: Any
    is_comparison: Any
    natural_self_precedent: Any
    opstring: Any
    precedence: Any
    return_type: Any
    def __call__(self, left, right, **kw) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __hash__(self) -> int: ...
    def __init__(self, opstring, precedence = ..., is_comparison = ..., return_type = ..., natural_self_precedent = ..., eager_grouping = ...) -> None: ...

def _escaped_like_impl(fn, other, escape, autoescape) -> Any: ...
def add(__a, __b) -> Any: ...
def all_op(a) -> Any: ...
def and_(__a, __b) -> Any: ...
def any_op(a) -> Any: ...
def as_() -> NoReturn: ...
def asc_op(a) -> Any: ...
def between_op(a, b, c, symmetric = ...) -> Any: ...
def collate(a, b) -> Any: ...
def comma_op(a, b) -> NoReturn: ...
def commutative_op(fn: _T0) -> _T0: ...
def comparison_op(fn: _T0) -> _T0: ...
def concat_op(a, b) -> Any: ...
def contains(__a: Container, __b) -> bool: ...
def contains_op(a, b, escape = ..., autoescape = ...) -> Any: ...
def desc_op(a) -> Any: ...
def distinct_op(a) -> Any: ...
def empty_in_op(a, b) -> NoReturn: ...
def empty_notin_op(a, b) -> NoReturn: ...
def endswith_op(a, b, escape = ..., autoescape = ...) -> Any: ...
def eq(__a, __b) -> Any: ...
def exists() -> NoReturn: ...
def filter_op(a, b) -> NoReturn: ...
def from_() -> NoReturn: ...
def function_as_comparison_op() -> NoReturn: ...
def ge(__a, __b) -> Any: ...
@overload
def getitem(__a: Mapping[_K, _V], __b: _K) -> _V: ...
@overload
def getitem(__a: Sequence[_T], __b: int) -> _T: ...
def gt(__a, __b) -> Any: ...
def ilike_op(a, b, escape = ...) -> Any: ...
def in_op(a, b) -> Any: ...
def inv(__a) -> Any: ...
def is_(a, b) -> Any: ...
def is_boolean(op) -> Any: ...
def is_commutative(op) -> bool: ...
def is_comparison(op) -> Any: ...
def is_distinct_from(a, b) -> Any: ...
def is_natural_self_precedent(op) -> Any: ...
def is_ordering_modifier(op) -> bool: ...
def is_precedent(operator, against) -> Any: ...
def isfalse(a) -> NoReturn: ...
def isnot(a, b) -> Any: ...
def isnot_distinct_from(a, b) -> Any: ...
def istrue(a) -> NoReturn: ...
def json_getitem_op(a, b) -> NoReturn: ...
def json_path_getitem_op(a, b) -> NoReturn: ...
def le(__a, __b) -> Any: ...
def like_op(a, b, escape = ...) -> Any: ...
def lshift(__a, __b) -> Any: ...
def lt(__a, __b) -> Any: ...
def match_op(a, b, **kw) -> Any: ...
def mirror(op: _T0) -> Union[Callable[[Any, Any], Any], _T0]: ...
def mod(__a, __b) -> Any: ...
def mul(__a, __b) -> Any: ...
def ne(__a, __b) -> Any: ...
def neg(__a) -> Any: ...
def notbetween_op(a, b, c, symmetric = ...) -> Any: ...
def notcontains_op(a, b, escape = ..., autoescape = ...) -> Any: ...
def notendswith_op(a, b, escape = ..., autoescape = ...) -> Any: ...
def notilike_op(a, b, escape = ...) -> Any: ...
def notin_op(a, b) -> Any: ...
def notlike_op(a, b, escape = ...) -> Any: ...
def notmatch_op(a, b, **kw) -> Any: ...
def notstartswith_op(a, b, escape = ..., autoescape = ...) -> Any: ...
def nullsfirst_op(a) -> Any: ...
def nullslast_op(a) -> Any: ...
def op(a, opstring, b) -> Any: ...
def or_(__a, __b) -> Any: ...
def rshift(__a, __b) -> Any: ...
def startswith_op(a, b, escape = ..., autoescape = ...) -> Any: ...
def sub(__a, __b) -> Any: ...
def truediv(__a, __b) -> Any: ...
