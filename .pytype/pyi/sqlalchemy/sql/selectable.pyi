# (generated with --quick)

import sqlalchemy.sql.annotation
import sqlalchemy.sql.base
import sqlalchemy.sql.elements
import sqlalchemy.sql.visitors
import sqlalchemy.util._collections
from typing import Any, Callable, Dict, Generator, List, NoReturn, Optional, Set, Tuple, Type, TypeVar, Union

Annotated: Type[sqlalchemy.sql.annotation.Annotated]
BindParameter: Type[sqlalchemy.sql.elements.BindParameter]
ClauseElement: Type[sqlalchemy.sql.elements.ClauseElement]
ClauseList: Type[sqlalchemy.sql.elements.ClauseList]
ColumnCollection: Type[sqlalchemy.sql.base.ColumnCollection]
ColumnSet: Type[sqlalchemy.sql.base.ColumnSet]
Executable: Type[sqlalchemy.sql.base.Executable]
Generative: Type[sqlalchemy.sql.base.Generative]
Grouping: Type[sqlalchemy.sql.elements.Grouping]
Immutable: Type[sqlalchemy.sql.base.Immutable]
True_: Type[sqlalchemy.sql.elements.True_]
UnaryExpression: Type[sqlalchemy.sql.elements.UnaryExpression]
Visitable: Type[sqlalchemy.sql.visitors.Visitable]
_anonymous_label: Type[sqlalchemy.sql.elements._anonymous_label]
_generative: Any
collections: module
exc: module
inspection: module
itertools: module
operator: module
operators: module
type_api: module
util: module

_T0 = TypeVar('_T0')
_TCompoundSelect = TypeVar('_TCompoundSelect', bound=CompoundSelect)
_TFromGrouping = TypeVar('_TFromGrouping', bound=FromGrouping)
_TJoin = TypeVar('_TJoin', bound=Join)
_TScalarSelect = TypeVar('_TScalarSelect', bound=ScalarSelect)

class Alias(FromClause):
    __doc__: str
    __visit_name__: str
    _execution_options: Any
    _from_objects: list
    _is_from_container: bool
    bind: Any
    description: Any
    element: Any
    name: Any
    named_with_column: bool
    original: Any
    supports_execution: Any
    def __init__(self, *arg, **kw) -> NoReturn: ...
    @classmethod
    def _construct(cls, *arg, **kw) -> Any: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    @classmethod
    def _factory(cls, selectable, name = ..., flat = ...) -> Any: ...
    def _init(self, selectable, name = ...) -> None: ...
    def _populate_column_collection(self) -> None: ...
    def _refresh_for_new_column(self, column) -> Any: ...
    def as_scalar(self) -> Any: ...
    def get_children(self, column_collections = ..., **kw) -> Generator[Any, Any, None]: ...
    def is_derived_from(self, fromclause) -> Any: ...
    def self_group(self, against = ...) -> Union[Alias, FromGrouping]: ...

class AnnotatedFromClause(sqlalchemy.sql.annotation.Annotated):
    def __init__(self, element, values) -> None: ...

class CTE(sqlalchemy.sql.base.Generative, HasPrefixes, HasSuffixes, Alias):
    __doc__: str
    __visit_name__: str
    _cte_alias: Any
    _populate_column_collection: Any
    _prefixes: Any
    _restates: Any
    _suffixes: Any
    recursive: Any
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    @classmethod
    def _factory(cls, selectable, name = ..., recursive = ...) -> Any: ...
    def _init(self, selectable, name = ..., recursive = ..., _cte_alias = ..., _restates = ..., _prefixes = ..., _suffixes = ...) -> None: ...
    def alias(self, name = ..., flat = ...) -> Any: ...
    def union(self, other) -> Any: ...
    def union_all(self, other) -> Any: ...

class CompoundSelect(GenerativeSelect):
    EXCEPT: Any
    EXCEPT_ALL: Any
    INTERSECT: Any
    INTERSECT_ALL: Any
    UNION: Any
    UNION_ALL: Any
    __doc__: str
    __visit_name__: str
    _auto_correlate: Any
    _bind: Any
    _is_from_container: bool
    _label_resolve_dict: Tuple[dict, dict, dict]
    bind: Any
    keyword: Any
    selects: Any
    use_labels: bool
    def __init__(self, keyword, *selects, **kwargs) -> None: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    @classmethod
    def _create_except(cls: Type[_TCompoundSelect], *selects, **kwargs) -> _TCompoundSelect: ...
    @classmethod
    def _create_except_all(cls: Type[_TCompoundSelect], *selects, **kwargs) -> _TCompoundSelect: ...
    @classmethod
    def _create_intersect(cls: Type[_TCompoundSelect], *selects, **kwargs) -> _TCompoundSelect: ...
    @classmethod
    def _create_intersect_all(cls: Type[_TCompoundSelect], *selects, **kwargs) -> _TCompoundSelect: ...
    @classmethod
    def _create_union(cls: Type[_TCompoundSelect], *selects, **kwargs) -> _TCompoundSelect: ...
    @classmethod
    def _create_union_all(cls: Type[_TCompoundSelect], *selects, **kwargs) -> _TCompoundSelect: ...
    def _populate_column_collection(self) -> None: ...
    def _refresh_for_new_column(self, column) -> None: ...
    def _scalar_type(self) -> Any: ...
    def _set_bind(self, bind) -> None: ...
    def get_children(self, column_collections = ..., **kwargs) -> list: ...
    def is_derived_from(self, fromclause) -> bool: ...
    def self_group(self, against = ...) -> FromGrouping: ...

class Exists(sqlalchemy.sql.elements.UnaryExpression):
    __doc__: str
    __visit_name__: str
    _from_objects: List[nothing]
    def __init__(self, *args, **kwargs) -> None: ...
    def correlate(self, *fromclause) -> Any: ...
    def correlate_except(self, *fromclause) -> Any: ...
    def select(self, whereclause = ..., **params) -> Select: ...
    def select_from(self, clause) -> Any: ...
    def where(self, clause) -> Any: ...

class ForUpdateArg(sqlalchemy.sql.elements.ClauseElement):
    key_share: Any
    legacy_for_update_value: Union[bool, str]
    nowait: Any
    of: Any
    read: Any
    skip_locked: Any
    def __eq__(self, other) -> Any: ...
    def __hash__(self) -> int: ...
    def __init__(self, nowait = ..., read = ..., of = ..., skip_locked = ..., key_share = ...) -> None: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    @classmethod
    def parse_legacy_select(self: Type[ForUpdateArg], arg) -> Optional[ForUpdateArg]: ...

class FromClause(Selectable):
    __doc__: str
    __visit_name__: str
    _cols_populated: bool
    _columns: sqlalchemy.sql.base.ColumnCollection
    _hide_froms: List[nothing]
    _is_from_container: bool
    _is_join: bool
    _is_lateral: bool
    _is_select: bool
    _memoized_property: Any
    _select_iterable: Any
    _textual: bool
    c: Any
    columns: Any
    count: Any
    description: Any
    foreign_keys: Any
    named_with_column: bool
    primary_key: Any
    replace_selectable: Any
    schema: None
    def _init_collections(self) -> None: ...
    def _is_lexical_equivalent(self, other) -> Any: ...
    def _populate_column_collection(self) -> None: ...
    def _refresh_for_new_column(self, column: _T0) -> Optional[_T0]: ...
    def _reset_exported(self) -> None: ...
    def _translate_schema(self, effective_schema: _T0, map_) -> _T0: ...
    def alias(self, name = ..., flat = ...) -> Any: ...
    def correspond_on_equivalents(self, column, equivalents) -> Any: ...
    def corresponding_column(self, column, require_embedded = ...) -> Any: ...
    def is_derived_from(self, fromclause) -> bool: ...
    def join(self, right, onclause = ..., isouter = ..., full = ...) -> Join: ...
    def lateral(self, name = ...) -> Any: ...
    def outerjoin(self, right, onclause = ..., full = ...) -> Join: ...
    def select(self, whereclause = ..., **params) -> Select: ...
    def tablesample(self, sampling, name = ..., seed = ...) -> Any: ...

class FromGrouping(FromClause):
    __doc__: str
    __visit_name__: str
    _from_objects: Any
    _hide_froms: Any
    columns: Any
    element: Any
    foreign_keys: Any
    primary_key: Any
    def __getattr__(self, attr) -> Any: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __init__(self, element) -> None: ...
    def __setstate__(self, state) -> None: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    def _init_collections(self) -> None: ...
    def alias(self: _TFromGrouping, **kw) -> _TFromGrouping: ...
    def get_children(self, **kwargs) -> Tuple[Any]: ...
    def is_derived_from(self, element) -> Any: ...

class GenerativeSelect(SelectBase):
    __doc__: str
    _bind: Any
    _execution_options: Any
    _for_update_arg: Any
    _group_by_clause: sqlalchemy.sql.elements.ClauseList
    _limit: Any
    _limit_clause: Any
    _offset: Any
    _offset_clause: Any
    _order_by_clause: sqlalchemy.sql.elements.ClauseList
    _simple_int_limit: bool
    _simple_int_offset: bool
    apply_labels: Any
    for_update: Any
    group_by: Any
    limit: Any
    offset: Any
    order_by: Any
    use_labels: Any
    with_for_update: Any
    def __init__(self, use_labels = ..., for_update = ..., limit = ..., offset = ..., order_by = ..., group_by = ..., bind = ..., autocommit = ...) -> None: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    def append_group_by(self, *clauses) -> None: ...
    def append_order_by(self, *clauses) -> None: ...

class HasCTE:
    __doc__: str
    def cte(self, name = ..., recursive = ...) -> Any: ...

class HasPrefixes:
    _prefixes: tuple
    prefix_with: Any
    def _setup_prefixes(self, prefixes, dialect = ...) -> None: ...

class HasSuffixes:
    _suffixes: tuple
    suffix_with: Any
    def _setup_suffixes(self, suffixes, dialect = ...) -> None: ...

class Join(FromClause):
    __doc__: str
    __visit_name__: str
    _from_objects: list
    _hide_froms: itertools.chain[nothing]
    _is_join: bool
    _join_condition: Any
    _populate_column_collection: Any
    alias: Any
    bind: Any
    description: str
    full: Any
    isouter: Any
    left: Any
    onclause: Any
    right: Any
    def __init__(self, left, right, onclause = ..., isouter = ..., full = ...) -> None: ...
    @classmethod
    def _can_join(cls, left, right, consider_as_foreign_keys = ...) -> bool: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    @classmethod
    def _create_join(cls: Type[_TJoin], left, right, onclause = ..., isouter = ..., full = ...) -> _TJoin: ...
    @classmethod
    def _create_outerjoin(cls: Type[_TJoin], left, right, onclause = ..., full = ...) -> _TJoin: ...
    @classmethod
    def _joincond_scan_left_right(cls, a, a_subset, b, consider_as_foreign_keys) -> collections.defaultdict: ...
    @classmethod
    def _joincond_trim_constraints(cls, a, b, constraints, consider_as_foreign_keys) -> None: ...
    def _match_primaries(self, left, right) -> Any: ...
    def _refresh_for_new_column(self, column) -> Any: ...
    def get_children(self, **kwargs) -> Tuple[Any, Any, Any]: ...
    def is_derived_from(self, fromclause) -> Any: ...
    def select(self, whereclause = ..., **kwargs) -> Select: ...
    def self_group(self, against = ...) -> FromGrouping: ...

class Lateral(Alias):
    __doc__: str
    __visit_name__: str
    _is_lateral: bool
    @classmethod
    def _factory(cls, selectable, name = ...) -> Any: ...

class ScalarSelect(sqlalchemy.sql.base.Generative, sqlalchemy.sql.elements.Grouping):
    _from_objects: List[nothing]
    _is_from_container: bool
    _is_implicitly_boolean: bool
    element: Any
    type: Any
    where: Any
    def __init__(self, element) -> None: ...
    def self_group(self: _TScalarSelect, **kwargs) -> _TScalarSelect: ...

class Select(HasPrefixes, HasSuffixes, GenerativeSelect):
    __doc__: str
    __init__: Any
    __visit_name__: str
    _auto_correlate: bool
    _bind: Any
    _columns_plus_names: Any
    _correlate: Union[set, Tuple[()]]
    _correlate_except: Optional[set]
    _distinct: bool
    _from_cloned: Optional[dict]
    _from_obj: sqlalchemy.util._collections.OrderedSet
    _froms: list
    _having: Any
    _hints: sqlalchemy.util._collections.immutabledict
    _is_select: bool
    _label_resolve_dict: Any
    _memoized_property: Any
    _prefixes: tuple
    _raw_columns: Any
    _statement_hints: Tuple[()]
    _suffixes: Tuple[()]
    _whereclause: Any
    bind: Any
    column: Any
    correlate: Any
    correlate_except: Any
    distinct: Any
    froms: Any
    having: Any
    inner_columns: itertools.chain[nothing]
    locate_all_froms: Any
    reduce_columns: Any
    select_from: Any
    where: Any
    with_hint: Any
    with_only_columns: Any
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    def _get_display_froms(self, explicit_correlate_froms = ..., implicit_correlate_froms = ...) -> Any: ...
    def _needs_parens_for_grouping(self) -> bool: ...
    def _populate_column_collection(self) -> None: ...
    def _refresh_for_new_column(self, column) -> Any: ...
    def _scalar_type(self) -> Any: ...
    def _set_bind(self, bind) -> None: ...
    def append_column(self, column) -> None: ...
    def append_correlation(self, fromclause) -> None: ...
    def append_from(self, fromclause) -> None: ...
    def append_having(self, having) -> None: ...
    def append_prefix(self, clause) -> None: ...
    def append_whereclause(self, whereclause) -> None: ...
    def except_(self, other, **kwargs) -> Any: ...
    def except_all(self, other, **kwargs) -> Any: ...
    def get_children(self, column_collections = ..., **kwargs) -> list: ...
    def intersect(self, other, **kwargs) -> Any: ...
    def intersect_all(self, other, **kwargs) -> Any: ...
    def is_derived_from(self, fromclause) -> bool: ...
    def self_group(self, against = ...) -> Union[FromGrouping, Select]: ...
    def union(self, other, **kwargs) -> Any: ...
    def union_all(self, other, **kwargs) -> Any: ...
    def with_statement_hint(self, text, dialect_name = ...) -> Any: ...

class SelectBase(HasCTE, sqlalchemy.sql.base.Executable, FromClause):
    __doc__: str
    _from_objects: list
    autocommit: Any
    def _generate(self) -> Any: ...
    def as_scalar(self) -> ScalarSelect: ...
    def label(self, name) -> Any: ...

class Selectable(sqlalchemy.sql.elements.ClauseElement):
    __doc__: str
    __visit_name__: str
    is_selectable: bool
    selectable: Any

class TableClause(sqlalchemy.sql.base.Immutable, FromClause):
    __doc__: str
    __visit_name__: str
    _autoincrement_column: None
    _columns: sqlalchemy.sql.base.ColumnCollection
    _from_objects: list
    delete: Any
    description: Any
    foreign_keys: Set[nothing]
    fullname: Any
    implicit_returning: bool
    insert: Any
    name: Any
    named_with_column: bool
    primary_key: sqlalchemy.sql.base.ColumnSet
    schema: Any
    update: Any
    def __init__(self, name, *columns, **kw) -> None: ...
    def _init_collections(self) -> None: ...
    def append_column(self, c) -> None: ...
    def get_children(self, column_collections = ..., **kwargs) -> Any: ...

class TableSample(Alias):
    __doc__: str
    __visit_name__: str
    _get_method: Any
    sampling: Any
    seed: Any
    @classmethod
    def _factory(cls, selectable, sampling, name = ..., seed = ...) -> Any: ...
    def _init(self, selectable, sampling, name = ..., seed = ...) -> None: ...

class TextAsFrom(SelectBase):
    __doc__: str
    __visit_name__: str
    _bind: Any
    _textual: bool
    bindparams: Any
    column_args: Any
    element: Any
    positional: Any
    def __init__(self, text, columns, positional = ...) -> None: ...
    def _copy_internals(self, clone = ..., **kw) -> None: ...
    def _populate_column_collection(self) -> None: ...
    def _scalar_type(self) -> Any: ...

class _OffsetLimitParam(sqlalchemy.sql.elements.BindParameter):
    _limit_offset_value: Any

def _clause_element_as_expr(element) -> Any: ...
def _clone(element, **kw) -> Any: ...
def _cloned_difference(a, b) -> set: ...
def _cloned_intersection(a, b) -> set: ...
def _document_text_coercion(paramname, meth_rst, param_rst) -> Any: ...
def _expand_cloned(elements) -> itertools.chain[nothing]: ...
def _from_objects(*elements) -> itertools.chain[nothing]: ...
def _interpret_as_column_or_from(element) -> Any: ...
def _interpret_as_from(element) -> Any: ...
def _interpret_as_select(element) -> Any: ...
def _literal_and_labels_as_label_reference(element) -> Any: ...
def _literal_as_label_reference(element) -> Any: ...
def _literal_as_text(element, allow_coercion_to_text = ...) -> Any: ...
def _no_text_coercion(element, exc_cls = ..., extra = ..., err = ...) -> NoReturn: ...
def _offset_or_limit_clause(element, name = ..., type_ = ...) -> Any: ...
def _offset_or_limit_clause_asint(clause, attrname) -> Any: ...
def _select_iterables(elements) -> itertools.chain[nothing]: ...
def and_(*clauses) -> Any: ...
def attrgetter(*attrs: str) -> Callable[[Any], tuple]: ...
def literal_column(text, type_ = ...) -> sqlalchemy.sql.elements.ColumnClause: ...
def subquery(alias, *args, **kwargs) -> Any: ...
