# (generated with --quick)

import collections
import itertools
import sqlalchemy.sql.base
import sqlalchemy.sql.elements
import sqlalchemy.sql.schema
import sqlalchemy.sql.selectable
import sqlalchemy.sql.visitors
from typing import Any, Dict, Generator, List, Set, Tuple, Type, TypeVar

Alias: Type[sqlalchemy.sql.selectable.Alias]
BindParameter: Type[sqlalchemy.sql.elements.BindParameter]
Column: Type[sqlalchemy.sql.schema.Column]
ColumnClause: Type[sqlalchemy.sql.elements.ColumnClause]
ColumnElement: Type[sqlalchemy.sql.elements.ColumnElement]
ColumnSet: Type[sqlalchemy.sql.base.ColumnSet]
FromClause: Type[sqlalchemy.sql.selectable.FromClause]
FromGrouping: Type[sqlalchemy.sql.selectable.FromGrouping]
Grouping: Type[sqlalchemy.sql.elements.Grouping]
Join: Type[sqlalchemy.sql.selectable.Join]
Label: Type[sqlalchemy.sql.elements.Label]
Null: Type[sqlalchemy.sql.elements.Null]
ScalarSelect: Type[sqlalchemy.sql.selectable.ScalarSelect]
SelectBase: Type[sqlalchemy.sql.selectable.SelectBase]
TableClause: Type[sqlalchemy.sql.selectable.TableClause]
UnaryExpression: Type[sqlalchemy.sql.elements.UnaryExpression]
_label_reference: Type[sqlalchemy.sql.elements._label_reference]
_textual_label_reference: Type[sqlalchemy.sql.elements._textual_label_reference]
chain: Type[itertools.chain]
deque: Type[collections.deque]
exc: module
join_condition: Any
operators: module
util: module
visitors: module

_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_TColumnAdapter = TypeVar('_TColumnAdapter', bound=ColumnAdapter)

class ClauseAdapter(sqlalchemy.sql.visitors.ReplacingCloningVisitor):
    __doc__: str
    __traverse_options__: Dict[str, Any]
    adapt_on_names: Any
    equivalents: dict
    exclude_fn: Any
    include_fn: Any
    selectable: Any
    def __init__(self, selectable, equivalents = ..., include_fn = ..., exclude_fn = ..., adapt_on_names = ..., anonymize_labels = ...) -> None: ...
    def _corresponding_column(self, col, require_embedded, _seen = ...) -> Any: ...
    def replace(self, col) -> Any: ...

class ColumnAdapter(ClauseAdapter):
    _IncludeExcludeMapping: type
    __doc__: str
    __traverse_options__: Dict[str, Any]
    _wrap: Any
    adapt_on_names: Any
    adapt_required: Any
    allow_label_resolve: Any
    columns: Any
    equivalents: dict
    exclude_fn: Any
    include_fn: Any
    selectable: Any
    def __getstate__(self) -> Dict[str, Any]: ...
    def __init__(self, selectable, equivalents = ..., adapt_required = ..., include_fn = ..., exclude_fn = ..., adapt_on_names = ..., allow_label_resolve = ..., anonymize_labels = ...) -> None: ...
    def __setstate__(self, state) -> None: ...
    def _locate_col(self, col) -> Any: ...
    def adapt_clause(self, obj) -> Any: ...
    def adapt_list(self: sqlalchemy.sql.visitors.CloningVisitor, list_) -> Any: ...
    def traverse(self, obj) -> Any: ...
    def wrap(self: _TColumnAdapter, adapter) -> _TColumnAdapter: ...

class _repr_base:
    __slots__ = ["max_chars"]
    _DICT: int
    _LIST: int
    _TUPLE: int
    def trunc(self, value) -> str: ...

class _repr_params(_repr_base):
    __slots__ = ["batches", "ismulti", "params"]
    __doc__: str
    batches: Any
    ismulti: Any
    max_chars: Any
    params: Any
    def __init__(self, params, batches, max_chars = ..., ismulti = ...) -> None: ...
    def __repr__(self) -> Any: ...
    def _repr_multi(self, multi_params, typ) -> str: ...
    def _repr_params(self, params, typ) -> str: ...

class _repr_row(_repr_base):
    __slots__ = ["row"]
    __doc__: str
    max_chars: Any
    row: Any
    def __init__(self, row, max_chars = ...) -> None: ...
    def __repr__(self) -> str: ...

def _deep_annotate(element, annotations, exclude = ...) -> Any: ...
def _deep_deannotate(element, values = ...) -> Any: ...
def _expand_cloned(elements) -> itertools.chain[nothing]: ...
def _find_columns(clause) -> Set[nothing]: ...
def _from_objects(*elements) -> itertools.chain[nothing]: ...
def _quote_ddl_expr(element) -> str: ...
def _shallow_annotate(element, annotations) -> Any: ...
def adapt_criterion_to_null(crit, nulls) -> Any: ...
def bind_values(clause) -> list: ...
def clause_is_present(clause, search) -> bool: ...
def criterion_as_pairs(expression, consider_as_foreign_keys = ..., consider_as_referenced_keys = ..., any_operator = ...) -> List[Tuple[Any, Any]]: ...
def expand_column_list_from_order_by(collist, order_by) -> Any: ...
def find_join_source(clauses, join_to) -> List[int]: ...
def find_left_clause_that_matches_given(clauses, join_from) -> List[int]: ...
def find_left_clause_to_join_from(clauses, join_to, onclause) -> Any: ...
def find_tables(clause, check_columns = ..., include_aliases = ..., include_joins = ..., include_selects = ..., include_crud = ...) -> list: ...
def reduce_columns(columns, *clauses, **kw) -> sqlalchemy.sql.base.ColumnSet: ...
def selectables_overlap(left, right) -> bool: ...
def sort_tables(tables, skip_fn = ..., extra_dependencies = ...) -> Any: ...
def splice_joins(left, right: _T1, stop_on = ...) -> _T1: ...
def surface_column_elements(clause: _T0, include_scalar_selects = ...) -> Generator[_T0, Any, None]: ...
def surface_selectables(clause: _T0) -> Generator[_T0, Any, Any]: ...
def surface_selectables_only(clause: _T0) -> Generator[_T0, Any, Any]: ...
def unwrap_label_reference(element) -> Any: ...
def unwrap_order_by(clause) -> list: ...
def visit_binary_product(fn, expr) -> None: ...
