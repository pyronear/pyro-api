# (generated with --quick)

import __builtin__
import collections
import contextlib
import datetime
import functools
import io
import sqlalchemy.util._collections
import sqlalchemy.util.compat
import sqlalchemy.util.langhelpers
from typing import Any, Callable, Dict, FrozenSet, Generator, Iterable, Iterator, List, NoReturn, Sequence, Set, Tuple, Type, TypeVar, Union

EMPTY_SET: FrozenSet[nothing]
EnsureKWArgType: Type[sqlalchemy.util.langhelpers.EnsureKWArgType]
IdentitySet: Type[sqlalchemy.util._collections.IdentitySet]
ImmutableContainer: Type[sqlalchemy.util._collections.ImmutableContainer]
ImmutableProperties: Type[sqlalchemy.util._collections.ImmutableProperties]
KeyedTuple: Type[sqlalchemy.util._collections.KeyedTuple]
LRUCache: Type[sqlalchemy.util._collections.LRUCache]
MemoizedSlots: Type[sqlalchemy.util.langhelpers.MemoizedSlots]
NoneType: Type[__builtin__.NoneType]
OrderedDict: Type[sqlalchemy.util._collections.OrderedDict]
OrderedIdentitySet: Type[sqlalchemy.util._collections.OrderedIdentitySet]
OrderedProperties: Type[sqlalchemy.util._collections.OrderedProperties]
OrderedSet: Type[sqlalchemy.util._collections.OrderedSet]
PluginLoader: Type[sqlalchemy.util.langhelpers.PluginLoader]
PopulateDict: Type[sqlalchemy.util._collections.PopulateDict]
Properties: Type[sqlalchemy.util._collections.Properties]
ScopedRegistry: Type[sqlalchemy.util._collections.ScopedRegistry]
StringIO: Type[io.StringIO]
ThreadLocalRegistry: Type[sqlalchemy.util._collections.ThreadLocalRegistry]
UniqueAppender: Type[sqlalchemy.util._collections.UniqueAppender]
WeakPopulateDict: Type[sqlalchemy.util._collections.WeakPopulateDict]
WeakSequence: Type[sqlalchemy.util._collections.WeakSequence]
arm: bool
binary_type: Type[bytes]
byte_buffer: Type[io.BytesIO]
classproperty: Type[sqlalchemy.util.langhelpers.classproperty]
collections_abc: module
column_dict: Type[dict]
column_set: Type[set]
cpython: bool
defaultdict: Type[collections.defaultdict]
dependencies: Type[sqlalchemy.util.langhelpers.dependencies]
group_expirable_memoized_property: Type[sqlalchemy.util.langhelpers.group_expirable_memoized_property]
hybridmethod: Type[sqlalchemy.util.langhelpers.hybridmethod]
hybridproperty: Type[sqlalchemy.util.langhelpers.hybridproperty]
immutabledict: Type[sqlalchemy.util._collections.immutabledict]
inject_docstring_text: Any
int_types: Tuple[Type[int]]
jython: bool
memoized_property: Type[sqlalchemy.util.langhelpers.memoized_property]
nested: Callable[..., contextlib._GeneratorContextManager]
ordered_column_set: Type[sqlalchemy.util._collections.OrderedSet]
osx: bool
partial: Type[functools.partial]
pickle: module
portable_instancemethod: Type[sqlalchemy.util.langhelpers.portable_instancemethod]
print_: Any
py2k: bool
py33: bool
py36: bool
py3k: bool
pypy: bool
safe_reraise: Type[sqlalchemy.util.langhelpers.safe_reraise]
string_types: Tuple[Type[str]]
symbol: Type[sqlalchemy.util.langhelpers.symbol]
text_type: Type[str]
threading: module
timezone: Type[datetime.timezone]
win32: bool

AnyStr = TypeVar('AnyStr', str, bytes)
_S = TypeVar('_S')
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')

def add_parameter_text(params, text) -> Callable[[Any], Any]: ...
def as_interface(obj, cls = ..., methods = ..., required = ...) -> Any: ...
def asbool(obj) -> bool: ...
def asint(value: _T0) -> Union[int, _T0]: ...
def assert_arg_type(arg: _T0, argtype, name) -> _T0: ...
def attrsetter(attrname) -> Any: ...
def b(s) -> Any: ...
def b64decode(x) -> bytes: ...
def b64encode(x) -> str: ...
def bool_or_str(*text) -> Callable[[Any], Any]: ...
def callable(obj) -> bool: ...
def chop_traceback(tb, exclude_prefix = ..., exclude_suffix = ...) -> Any: ...
def class_hierarchy(cls) -> list: ...
def clsname_as_plain_name(cls) -> str: ...
def cmp(a, b) -> Any: ...
def coerce_generator_arg(arg: _T0) -> Union[list, _T0]: ...
def coerce_kw_type(kw, key, type_, flexi_bool = ..., dest = ...) -> __builtin__.NoneType: ...
def constructor_copy(obj, cls, *args, **kw) -> Any: ...
def contextmanager(func: Callable[..., Iterator[_T]]) -> Callable[..., contextlib._GeneratorContextManager[_T]]: ...
def counter() -> Callable[[], Any]: ...
def decode_backslashreplace(text, encoding) -> Any: ...
def decode_slice(slc) -> tuple: ...
def decorator(target) -> Callable: ...
def deprecated(version, message = ..., add_deprecation_to_docstring = ...) -> Callable[[Any], Any]: ...
def deprecated_cls(version, message, constructor = ...) -> Callable[[Any], Any]: ...
def deprecated_params(**specs) -> Callable[[Any], Any]: ...
def dictlike_iteritems(dictlike) -> Any: ...
def dottedgetter(*attrs: str) -> Callable[[Any], tuple]: ...
def duck_type_collection(specimen, default = ...) -> Any: ...
def ellipses_string(value: _T0, len_ = ...) -> Union[str, _T0]: ...
def flatten_iterator(x) -> Generator[Any, Any, __builtin__.NoneType]: ...
def format_argspec_init(method, grouped = ...) -> Any: ...
def format_argspec_plus(fn, grouped = ...) -> dict: ...
def generic_repr(obj, additional_kw = ..., to_inspect = ..., omit_kwarg = ...) -> str: ...
def get_callable_argspec(fn, no_self = ..., _is_init = ...) -> Any: ...
def get_cls_kwargs(cls, _set: _T1 = ...) -> Union[__builtin__.NoneType, set, _T1]: ...
def get_func_kwargs(func) -> Any: ...
def getargspec_init(method) -> Union[sqlalchemy.util.compat.`namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`, Tuple[List[str], Union[__builtin__.NoneType, str], Union[__builtin__.NoneType, str], __builtin__.NoneType]]: ...
def has_dupes(sequence, target) -> bool: ...
def has_intersection(set_, iterable) -> bool: ...
def inspect_getfullargspec(func) -> sqlalchemy.util.compat.`namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`: ...
def iterate_attributes(cls) -> Generator[Tuple[str, Any], Any, __builtin__.NoneType]: ...
@overload
def iterbytes(collection: bytearray) -> bytearray_iterator: ...
@overload
def iterbytes(collection: Dict[_T, _T2]) -> Iterator[_T]: ...
@overload
def iterbytes(collection: Generator[_T]) -> Generator[_T]: ...
@overload
def iterbytes(collection: List[_T]) -> listiterator[_T]: ...
@overload
def iterbytes(collection: Set[_T]) -> setiterator[_T]: ...
@overload
def iterbytes(collection: Tuple[_T, ...]) -> tupleiterator[_T]: ...
@overload
def iterbytes(collection: Iterable[_T]) -> Iterator[_T]: ...
@overload
def iterbytes(func: Callable[[], Union[_T, _T2]], sentinel: _T) -> Iterator[_T2]: ...
def itertools_filter(function: Union[Callable[[_T], Any], __builtin__.NoneType], iterable: Iterable[_T]) -> Iterator[_T]: ...
def itertools_filterfalse(predicate: Union[Callable[[_T], object], __builtin__.NoneType], iterable: Iterable[_T]) -> Iterator[_T]: ...
def lightweight_named_tuple(name, fields) -> Any: ...
def map_bits(fn, n) -> Generator[Any, Any, __builtin__.NoneType]: ...
def md5_hex(x) -> str: ...
def memoized_instancemethod(fn) -> Callable: ...
def methods_equivalent(meth1, meth2) -> bool: ...
def monkeypatch_proxied_specials(into_cls, from_cls, skip = ..., only = ..., name = ..., from_instance = ...) -> __builtin__.NoneType: ...
def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: Union[__builtin__.NoneType, bool] = ..., rename: Union[__builtin__.NoneType, bool] = ...) -> type: ...
def next(iterator: Iterator[_T], default: _T2 = ...) -> Union[_T, _T2]: ...
def only_once(fn, retry_on_exception) -> Callable: ...
def parse_qsl(qs: Union[__builtin__.NoneType, AnyStr], keep_blank_values: Union[__builtin__.NoneType, bool] = ..., strict_parsing: Union[__builtin__.NoneType, bool] = ..., encoding: str = ..., errors: str = ..., max_num_fields: Union[__builtin__.NoneType, int] = ...) -> List[Tuple[AnyStr, AnyStr]]: ...
def pending_deprecation(version, message = ..., add_deprecation_to_docstring = ...) -> Callable[[Any], Any]: ...
@overload
def quote_plus(string: str, safe: Union[bytes, str] = ..., encoding: Union[__builtin__.NoneType, str] = ..., errors: Union[__builtin__.NoneType, str] = ...) -> str: ...
@overload
def quote_plus(string: bytes, safe: Union[bytes, str] = ...) -> str: ...
def quoted_token_parser(value) -> Any: ...
def raise_(exception, with_traceback = ..., replace_context = ..., from_ = ...) -> NoReturn: ...
def raise_from_cause(exception, exc_info = ...) -> __builtin__.NoneType: ...
@overload
def reduce(function: Callable[[_T, _S], _T], sequence: Iterable[_S], initial: _T) -> _T: ...
@overload
def reduce(function: Callable[[_T, _T], _T], sequence: Iterable[_T]) -> _T: ...
def reraise(tp, value, tb = ..., cause = ...) -> __builtin__.NoneType: ...
def safe_kwarg(arg: _T0) -> _T0: ...
def set_creation_order(instance) -> __builtin__.NoneType: ...
def to_column_set(x: _T0) -> Union[set, _T0]: ...
def to_list(x: _T0, default: _T1 = ...) -> Union[list, _T0, _T1]: ...
def to_set(x: _T0) -> Union[set, _T0]: ...
def u(s: _T0) -> _T0: ...
def ue(s: _T0) -> _T0: ...
def unbound_method_to_callable(func_or_cls) -> Any: ...
def unique_list(seq, hashfunc = ...) -> Any: ...
def unquote(string: str, encoding: str = ..., errors: str = ...) -> str: ...
def unquote_plus(string: str, encoding: str = ..., errors: str = ...) -> str: ...
def update_copy(d, _new = ..., **kw) -> Any: ...
def update_wrapper(wrapper: Callable, wrapped: Callable, assigned: Sequence[str] = ..., updated: Sequence[str] = ...) -> Callable: ...
def warn(msg) -> __builtin__.NoneType: ...
def warn_deprecated(msg, stacklevel = ...) -> __builtin__.NoneType: ...
def warn_exception(func, *args, **kwargs) -> Any: ...
def warn_limited(msg, args) -> __builtin__.NoneType: ...
def warn_pending_deprecation(msg, stacklevel = ...) -> __builtin__.NoneType: ...
def with_metaclass(meta, *bases) -> Any: ...
def wrap_callable(wrapper: _T0, fn) -> Union[Callable, _T0]: ...
def zip_longest(*p: Iterable, fillvalue = ...) -> Iterator: ...
