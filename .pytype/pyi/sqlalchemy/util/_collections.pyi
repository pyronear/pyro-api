# (generated with --quick)

import __future__
import _weakref
from typing import Any, Callable, Dict, FrozenSet, Generator, Iterable, Iterator, List, NoReturn, Optional, Tuple, Type, TypeVar, Union

ordered_column_set = OrderedSet

EMPTY_SET: FrozenSet[nothing]
_getters: PopulateDict
_lw_tuples: LRUCache
_property_getters: PopulateDict
absolute_import: __future__._Feature
binary_types: Tuple[Type[bytes]]
collections_abc: module
column_dict: Type[dict]
column_set: Type[set]
operator: module
py2k: bool
string_types: Tuple[Type[str]]
threading: module
types: module
weakref: module

_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_TIdentitySet = TypeVar('_TIdentitySet', bound=IdentitySet)
_TKeyedTuple = TypeVar('_TKeyedTuple', bound=KeyedTuple)
_TOrderedDict = TypeVar('_TOrderedDict', bound=OrderedDict)
_TOrderedSet = TypeVar('_TOrderedSet', bound=OrderedSet)
_T_LW = TypeVar('_T_LW', bound=_LW)
_Timmutabledict = TypeVar('_Timmutabledict', bound=immutabledict)

class AbstractKeyedTuple(tuple):
    __slots__ = []
    def keys(self) -> list: ...

class IdentitySet:
    __doc__: str
    _members: Any
    def __and__(self, other) -> Any: ...
    def __cmp__(self, other) -> NoReturn: ...
    def __contains__(self, value) -> bool: ...
    def __copy__(self: _TIdentitySet) -> _TIdentitySet: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __hash__(self) -> NoReturn: ...
    def __iand__(self, other) -> Union[IdentitySet, NotImplementedType]: ...
    def __init__(self, iterable = ...) -> None: ...
    def __ior__(self, other) -> Union[IdentitySet, NotImplementedType]: ...
    def __isub__(self, other) -> Union[IdentitySet, NotImplementedType]: ...
    def __iter__(self) -> Iterator[nothing]: ...
    def __ixor__(self, other) -> Union[IdentitySet, NotImplementedType]: ...
    def __le__(self, other) -> Any: ...
    def __len__(self) -> int: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> bool: ...
    def __or__(self, other) -> Any: ...
    def __repr__(self) -> str: ...
    def __sub__(self, other) -> Any: ...
    def __xor__(self, other) -> Any: ...
    def add(self, value) -> None: ...
    def clear(self) -> None: ...
    def copy(self: _TIdentitySet) -> _TIdentitySet: ...
    def difference(self: _TIdentitySet, iterable) -> _TIdentitySet: ...
    def difference_update(self, iterable) -> None: ...
    def discard(self, value) -> None: ...
    def intersection(self: _TIdentitySet, iterable) -> _TIdentitySet: ...
    def intersection_update(self, iterable) -> None: ...
    def issubset(self, iterable) -> bool: ...
    def issuperset(self, iterable) -> bool: ...
    def pop(self) -> Any: ...
    def remove(self, value) -> None: ...
    def symmetric_difference(self: _TIdentitySet, iterable) -> _TIdentitySet: ...
    def symmetric_difference_update(self, iterable) -> None: ...
    def union(self: _TIdentitySet, iterable) -> _TIdentitySet: ...
    def update(self, iterable) -> None: ...

class ImmutableContainer:
    def __delitem__(self, *arg, **kw) -> NoReturn: ...
    def __setattr__(self, *arg, **kw) -> NoReturn: ...
    def __setitem__(self, *arg, **kw) -> NoReturn: ...
    def _immutable(self, *arg, **kw) -> NoReturn: ...

class ImmutableProperties(ImmutableContainer, Properties):
    __slots__ = []
    __doc__: str

class KeyedTuple(AbstractKeyedTuple):
    __doc__: str
    _fields: tuple
    def __new__(cls: Type[_TKeyedTuple], vals, labels = ...) -> _TKeyedTuple: ...
    def __setattr__(self, key, value) -> NoReturn: ...
    def _asdict(self) -> Any: ...

class LRUCache(dict):
    __slots__ = ["_counter", "_mutex", "capacity", "size_alert", "threshold"]
    __doc__: str
    _counter: int
    _mutex: Any
    capacity: Any
    size_alert: Any
    size_threshold: Any
    threshold: Any
    def __getitem__(self, key) -> Any: ...
    def __init__(self, capacity = ..., threshold = ..., size_alert = ...) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def _inc_counter(self) -> int: ...
    def _manage_size(self) -> None: ...
    def get(self, key, default = ...) -> Any: ...
    def setdefault(self, key, value) -> Any: ...
    def values(self) -> Any: ...

class OrderedDict(dict):
    __slots__ = ["_list"]
    __doc__: str
    _list: list
    def __copy__(self: _TOrderedDict) -> _TOrderedDict: ...
    def __delitem__(self, key) -> None: ...
    def __init__(self, _OrderedDict____sequence = ..., **kwargs) -> None: ...
    def __iter__(self) -> listiterator[nothing]: ...
    def __reduce__(self) -> Tuple[Type[OrderedDict], Tuple[Any]]: ...
    def __setitem__(self, key, obj) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> Any: ...
    def items(self) -> Any: ...
    def iteritems(self) -> Any: ...
    def iterkeys(self) -> Iterator: ...
    def itervalues(self) -> Any: ...
    def keys(self) -> list: ...
    def pop(self, key, *default) -> Any: ...
    def popitem(self) -> Tuple[Any, Any]: ...
    def setdefault(self, key, value: _T1) -> Any: ...
    def sort(self, *arg, **kw) -> None: ...
    def update(self, _OrderedDict____sequence = ..., **kwargs) -> None: ...
    def values(self) -> Any: ...

class OrderedIdentitySet(IdentitySet):
    _members: OrderedDict
    def __init__(self, iterable = ...) -> None: ...

class OrderedProperties(Properties):
    __slots__ = []
    __doc__: str
    def __init__(self) -> None: ...

class OrderedSet(set):
    _list: Any
    def __add__(self, other) -> Any: ...
    def __and__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def __getitem__(self, key) -> Any: ...
    def __iand__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def __init__(self, d = ...) -> None: ...
    def __ior__(self: _TOrderedSet, iterable) -> _TOrderedSet: ...
    def __isub__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def __iter__(self) -> Any: ...
    def __ixor__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def __or__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __sub__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def __xor__(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def add(self, element) -> None: ...
    def clear(self) -> None: ...
    def difference(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def difference_update(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def discard(self, element) -> None: ...
    def insert(self, pos, element) -> None: ...
    def intersection(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def intersection_update(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def remove(self, element) -> None: ...
    def symmetric_difference(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def symmetric_difference_update(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def union(self: _TOrderedSet, other) -> _TOrderedSet: ...
    def update(self: _TOrderedSet, iterable) -> _TOrderedSet: ...

class PopulateDict(dict):
    __doc__: str
    creator: Any
    def __init__(self, creator) -> None: ...
    def __missing__(self, key) -> Any: ...

class Properties:
    __slots__ = ["_data"]
    __doc__: str
    def __add__(self, other) -> list: ...
    def __contains__(self, key) -> bool: ...
    def __delitem__(self, key) -> None: ...
    def __dir__(self) -> list: ...
    def __getattr__(self, key) -> Any: ...
    def __getitem__(self, key) -> Any: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __init__(self, data) -> None: ...
    def __iter__(self) -> listiterator: ...
    def __len__(self) -> int: ...
    def __setattr__(self, key, obj) -> None: ...
    def __setitem__(self, key, obj) -> None: ...
    def __setstate__(self, state) -> None: ...
    def as_immutable(self) -> ImmutableProperties: ...
    def clear(self) -> None: ...
    def get(self, key, default = ...) -> Any: ...
    def has_key(self, key) -> bool: ...
    def items(self) -> list: ...
    def keys(self) -> list: ...
    def update(self, value) -> None: ...
    def values(self) -> list: ...

class ScopedRegistry:
    __doc__: str
    registry: dict
    def __call__(self) -> Any: ...
    def __init__(self, createfunc, scopefunc) -> None: ...
    def clear(self) -> None: ...
    def createfunc(self) -> Any: ...
    def has(self) -> bool: ...
    def scopefunc(self) -> Any: ...
    def set(self, obj) -> None: ...

class ThreadLocalRegistry(ScopedRegistry):
    __doc__: str
    registry: Any
    def __call__(self) -> Any: ...
    def __init__(self, createfunc) -> None: ...
    def clear(self) -> None: ...
    def createfunc(self) -> Any: ...
    def has(self) -> bool: ...
    def set(self, obj) -> None: ...

class UniqueAppender:
    __doc__: str
    _data_appender: Any
    _unique: Dict[int, bool]
    data: Any
    def __init__(self, data, via = ...) -> None: ...
    def __iter__(self) -> Any: ...
    def append(self, item) -> None: ...

class WeakPopulateDict(dict):
    __doc__: str
    creator: Any
    weakself: _weakref.ReferenceType[nothing]
    def __init__(self, creator_method) -> None: ...
    def __missing__(self, key) -> Any: ...

class WeakSequence:
    _remove: Callable
    _storage: Any
    def __getitem__(self, index) -> Any: ...
    def __init__(self, _WeakSequence__elements = ...) -> None: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    def append(self, item) -> None: ...

class _LW(AbstractKeyedTuple):
    __slots__ = []
    def __new__(cls: Type[_T_LW], vals) -> _T_LW: ...
    def __reduce__(self) -> Tuple[Type[KeyedTuple], Tuple[List[nothing], Any]]: ...
    def _asdict(self) -> dict: ...

class immutabledict(ImmutableContainer, dict):
    def __init__(self, *args) -> None: ...
    def __new__(cls: Type[_Timmutabledict], *args) -> _Timmutabledict: ...
    def __reduce__(self) -> Tuple[Type[immutabledict], Tuple[dict]]: ...
    def __repr__(self) -> str: ...
    def clear(self: ImmutableContainer, *arg, **kw) -> NoReturn: ...
    def pop(self: ImmutableContainer, *arg, **kw) -> NoReturn: ...
    def popitem(self: ImmutableContainer, *arg, **kw) -> NoReturn: ...
    def setdefault(self: ImmutableContainer, *arg, **kw) -> NoReturn: ...
    def union(self, d) -> Any: ...
    def update(self: ImmutableContainer, *arg, **kw) -> NoReturn: ...

def coerce_generator_arg(arg: _T0) -> Union[list, _T0]: ...
def flatten_iterator(x) -> Generator[Any, Any, None]: ...
def has_dupes(sequence, target) -> bool: ...
def has_intersection(set_, iterable) -> bool: ...
def itertools_filterfalse(predicate: Optional[Callable[[_T], object]], iterable: Iterable[_T]) -> Iterator[_T]: ...
def lightweight_named_tuple(name, fields) -> Any: ...
def to_column_set(x: _T0) -> Union[set, _T0]: ...
def to_list(x: _T0, default: _T1 = ...) -> Union[list, _T0, _T1]: ...
def to_set(x: _T0) -> Union[set, _T0]: ...
def unique_list(seq, hashfunc = ...) -> Any: ...
def update_copy(d, _new = ..., **kw) -> Any: ...
