# (generated with --quick)

import __builtin__
from typing import Any, Callable, Dict, Generator, NoReturn, Pattern, Sequence, Tuple, Type, TypeVar, Union

NoneType: Type[__builtin__.NoneType]
_SQLA_RE: Pattern[str]
_UNITTEST_RE: Pattern[str]
_collections: Any
_creation_order: int
compat: Any
exc: module
hashlib: module
inspect: module
itertools: module
operator: module
re: module
sys: module
textwrap: module
types: module
warnings: module

_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T_symbol = TypeVar('_T_symbol', bound=_symbol)

class EnsureKWArgType(type):
    __doc__: str
    def __init__(cls: EnsureKWArgType, clsname, bases, clsdict) -> __builtin__.NoneType: ...
    def _wrap_w_kw(self, fn) -> Callable: ...

class MemoizedSlots:
    __slots__ = []
    __doc__: str
    def __getattr__(self, key) -> Any: ...
    def _fallback_getattr(self, key) -> NoReturn: ...

class PluginLoader:
    group: Any
    impls: dict
    def __init__(self, group, auto_fn = ...) -> __builtin__.NoneType: ...
    def auto_fn(self, _1) -> Any: ...
    def clear(self) -> __builtin__.NoneType: ...
    def load(self, name) -> Any: ...
    def register(self, name, modulepath, objname) -> __builtin__.NoneType: ...

class _hash_limit_string(Any):
    __doc__: str
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> Any: ...
    def __new__(cls, value, num, args) -> Any: ...

class _symbol(int):
    __doc__: Any
    name: Any
    def __new__(self: Type[_T_symbol], name, doc = ..., canonical = ...) -> _T_symbol: ...
    def __reduce__(self) -> Tuple[Type[symbol], Tuple[Any, str, int]]: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class classproperty(property):
    __doc__: Any
    def __get__(desc: classproperty, self, cls) -> Any: ...
    def __init__(self, fget, *arg, **kw) -> __builtin__.NoneType: ...

class dependencies:
    __doc__: str
    _by_key: dict
    _importlater: type
    _unresolved: set
    import_deps: list
    def __call__(self, fn) -> Callable: ...
    def __init__(self, *deps) -> __builtin__.NoneType: ...
    @classmethod
    def resolve_all(cls, path) -> __builtin__.NoneType: ...

class group_expirable_memoized_property:
    __doc__: str
    attributes: list
    def __call__(self, fn) -> memoized_property: ...
    def __init__(self, attributes = ...) -> __builtin__.NoneType: ...
    def expire_instance(self, instance) -> __builtin__.NoneType: ...
    def method(self, fn) -> Any: ...

class hybridmethod:
    __doc__: str
    func: Any
    def __get__(self, instance, owner) -> Any: ...
    def __init__(self, func) -> __builtin__.NoneType: ...

class hybridproperty:
    def __get__(self, instance, owner) -> Any: ...
    def __init__(self, func) -> __builtin__.NoneType: ...
    def func(self, _1) -> Any: ...

class memoized_property:
    __doc__: Any
    fget: Any
    def __get__(self, obj, cls) -> Any: ...
    def __init__(self, fget, doc = ...) -> __builtin__.NoneType: ...
    def _reset(self, obj) -> __builtin__.NoneType: ...
    @classmethod
    def reset(cls, obj, name) -> __builtin__.NoneType: ...

class portable_instancemethod:
    __slots__ = ["__weakref__", "kwargs", "name", "target"]
    __doc__: str
    kwargs: Any
    name: Any
    target: Any
    def __call__(self, *arg, **kw) -> Any: ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __init__(self, meth, kwargs = ...) -> __builtin__.NoneType: ...
    def __setstate__(self, state) -> __builtin__.NoneType: ...

class safe_reraise:
    __slots__ = ["_exc_info", "warn_only"]
    __doc__: str
    _exc_info: Union[__builtin__.NoneType, Tuple[Union[__builtin__.NoneType, Type[BaseException]], Union[BaseException, __builtin__.NoneType], Union[__builtin__.NoneType, types.TracebackType]]]
    warn_only: Any
    def __enter__(self) -> __builtin__.NoneType: ...
    def __exit__(self, type_, value, traceback) -> __builtin__.NoneType: ...
    def __init__(self, warn_only = ...) -> __builtin__.NoneType: ...

class symbol:
    __doc__: Any
    _lock: Any
    symbols: dict
    def __new__(cls, name, doc = ..., canonical = ...) -> Any: ...
    @classmethod
    def parse_user_argument(cls, arg, choices, name, resolve_symbol_names = ...) -> Any: ...

def _dedent_docstring(text) -> Any: ...
def _exec_code_in_env(code, env, fn_name) -> Any: ...
def _inspect_func_args(fn) -> Tuple[Any, bool]: ...
def _unique_symbols(used, *bases) -> Generator[nothing, Any, __builtin__.NoneType]: ...
def add_parameter_text(params, text) -> Callable[[Any], Any]: ...
def as_interface(obj, cls = ..., methods = ..., required = ...) -> Any: ...
def asbool(obj) -> bool: ...
def asint(value: _T0) -> Union[int, _T0]: ...
def assert_arg_type(arg: _T0, argtype, name) -> _T0: ...
def attrsetter(attrname) -> Any: ...
def bool_or_str(*text) -> Callable[[Any], Any]: ...
def chop_traceback(tb, exclude_prefix = ..., exclude_suffix = ...) -> Any: ...
def class_hierarchy(cls) -> list: ...
def clsname_as_plain_name(cls) -> str: ...
def coerce_kw_type(kw, key, type_, flexi_bool = ..., dest = ...) -> __builtin__.NoneType: ...
def constructor_copy(obj, cls, *args, **kw) -> Any: ...
def counter() -> Callable[[], Any]: ...
def decode_slice(slc) -> tuple: ...
def decorator(target) -> Callable: ...
def dependency_for(modulename, add_to_all = ...) -> Callable[[Any], Any]: ...
def dictlike_iteritems(dictlike) -> Any: ...
def duck_type_collection(specimen, default = ...) -> Any: ...
def ellipses_string(value: _T0, len_ = ...) -> Union[str, _T0]: ...
def format_argspec_init(method, grouped = ...) -> Any: ...
def format_argspec_plus(fn, grouped = ...) -> dict: ...
def generic_repr(obj, additional_kw = ..., to_inspect = ..., omit_kwarg = ...) -> str: ...
def get_callable_argspec(fn, no_self = ..., _is_init = ...) -> Any: ...
def get_cls_kwargs(cls, _set: _T1 = ...) -> Union[__builtin__.NoneType, set, _T1]: ...
def get_func_kwargs(func) -> Any: ...
def getargspec_init(method) -> Any: ...
def inject_docstring_text(doctext, injecttext, pos) -> str: ...
def inject_param_text(doctext, inject_params) -> str: ...
def iterate_attributes(cls) -> Generator[Tuple[str, Any], Any, __builtin__.NoneType]: ...
def map_bits(fn, n) -> Generator[Any, Any, __builtin__.NoneType]: ...
def md5_hex(x) -> str: ...
def memoized_instancemethod(fn) -> Callable: ...
def methods_equivalent(meth1, meth2) -> bool: ...
def monkeypatch_proxied_specials(into_cls, from_cls, skip = ..., only = ..., name = ..., from_instance = ...) -> __builtin__.NoneType: ...
def only_once(fn, retry_on_exception) -> Callable: ...
def public_factory(target: _T0, location, class_location = ...) -> Union[Type[symbol], _T0]: ...
def quoted_token_parser(value) -> Any: ...
def repr_tuple_names(names) -> Union[__builtin__.NoneType, str]: ...
def set_creation_order(instance) -> __builtin__.NoneType: ...
def unbound_method_to_callable(func_or_cls) -> Any: ...
def update_wrapper(wrapper: Callable, wrapped: Callable, assigned: Sequence[str] = ..., updated: Sequence[str] = ...) -> Callable: ...
def warn(msg) -> __builtin__.NoneType: ...
def warn_exception(func, *args, **kwargs) -> Any: ...
def warn_limited(msg, args) -> __builtin__.NoneType: ...
def wrap_callable(wrapper: _T0, fn) -> Union[Callable, _T0]: ...
