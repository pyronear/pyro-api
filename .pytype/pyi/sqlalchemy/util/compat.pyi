# (generated with --quick)

import datetime
import io
from typing import Any, Callable, Dict, Generator, Iterable, Iterator, List, NoReturn, Optional, Set, Sized, Tuple, Type, TypeVar, Union

FullArgSpec = `namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`

StringIO: Type[io.StringIO]
arm: bool
base64: module
binary_type: Type[bytes]
binary_types: Tuple[Type[bytes]]
builtins: module
byte_buffer: Type[io.BytesIO]
collections: module
collections_abc: module
configparser: module
contextlib: module
cpython: bool
exec_: Any
import_: Any
inspect: module
int_types: Tuple[Type[int]]
itertools: module
jython: bool
nested: Callable[..., contextlib._GeneratorContextManager]
operator: module
osx: bool
pickle: module
platform: module
print_: Any
py265: bool
py2k: bool
py32: bool
py33: bool
py35: bool
py36: bool
py3k: bool
pypy: bool
string_types: Tuple[Type[str]]
sys: module
text_type: Type[str]
threading: module
timezone: Type[datetime.timezone]
win32: bool

AnyStr = TypeVar('AnyStr', str, bytes)
_S = TypeVar('_S')
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T2 = TypeVar('_T2')
_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations = TypeVar('_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations', bound=`namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`)

class `namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`(tuple):
    __slots__ = ["annotations", "args", "defaults", "kwonlyargs", "kwonlydefaults", "varargs", "varkw"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str, str, str, str, str, str]
    annotations: Any
    args: Any
    defaults: Any
    kwonlyargs: Any
    kwonlydefaults: Any
    varargs: Any
    varkw: Any
    def __getnewargs__(self) -> Tuple[Any, Any, Any, Any, Any, Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`], args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations) -> `_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`: ...
    def _replace(self: `_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`, **kwds) -> `_Tnamedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`: ...

def _formatannotation(annotation, base_module = ...) -> Any: ...
def b(s) -> Any: ...
def b64decode(x) -> bytes: ...
def b64encode(x) -> str: ...
def callable(obj) -> bool: ...
def cmp(a, b) -> Any: ...
def contextmanager(func: Callable[..., Iterator[_T]]) -> Callable[..., contextlib._GeneratorContextManager[_T]]: ...
def decode_backslashreplace(text, encoding) -> Any: ...
def dottedgetter(*attrs: str) -> Callable[[Any], tuple]: ...
def inspect_formatargspec(args, varargs = ..., varkw = ..., defaults = ..., kwonlyargs = ..., kwonlydefaults = ..., annotations = ..., formatarg = ..., formatvarargs = ..., formatvarkw = ..., formatvalue = ..., formatreturns = ..., formatannotation = ...) -> str: ...
def inspect_getfullargspec(func) -> `namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`: ...
@overload
def iterbytes(collection: bytearray) -> bytearray_iterator: ...
@overload
def iterbytes(collection: Dict[_T, _T2]) -> Iterator[_T]: ...
@overload
def iterbytes(collection: Generator[_T]) -> Generator[_T]: ...
@overload
def iterbytes(collection: List[_T]) -> listiterator[_T]: ...
@overload
def iterbytes(collection: Set[_T]) -> setiterator[_T]: ...
@overload
def iterbytes(collection: Tuple[_T, ...]) -> tupleiterator[_T]: ...
@overload
def iterbytes(collection: Iterable[_T]) -> Iterator[_T]: ...
@overload
def iterbytes(func: Callable[[], Union[_T, _T2]], sentinel: _T) -> Iterator[_T2]: ...
def itertools_filter(function: Optional[Callable[[_T], Any]], iterable: Iterable[_T]) -> Iterator[_T]: ...
def itertools_filterfalse(predicate: Optional[Callable[[_T], object]], iterable: Iterable[_T]) -> Iterator[_T]: ...
@overload
def itertools_imap(function, *sequences: Iterable[nothing]) -> Iterator[nothing]: ...
@overload
def itertools_imap(function: Callable[..., _T], *sequences: Iterable) -> Iterator[_T]: ...
def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: bool = ..., rename: bool = ...) -> type: ...
def next(iterator: Iterator[_T], default: _T2 = ...) -> Union[_T, _T2]: ...
def parse_qsl(qs: Optional[AnyStr], keep_blank_values: bool = ..., strict_parsing: bool = ..., encoding: str = ..., errors: str = ..., max_num_fields: Optional[int] = ...) -> List[Tuple[AnyStr, AnyStr]]: ...
@overload
def quote(string: str, safe: Union[bytes, str] = ..., encoding: Optional[str] = ..., errors: Optional[str] = ...) -> str: ...
@overload
def quote(string: bytes, safe: Union[bytes, str] = ...) -> str: ...
@overload
def quote_plus(string: str, safe: Union[bytes, str] = ..., encoding: Optional[str] = ..., errors: Optional[str] = ...) -> str: ...
@overload
def quote_plus(string: bytes, safe: Union[bytes, str] = ...) -> str: ...
def raise_(exception, with_traceback = ..., replace_context = ..., from_ = ...) -> NoReturn: ...
def raise_from_cause(exception, exc_info = ...) -> None: ...
@overload
def reduce(function: Callable[[_T, _S], _T], sequence: Iterable[_S], initial: _T) -> _T: ...
@overload
def reduce(function: Callable[[_T, _T], _T], sequence: Iterable[_T]) -> _T: ...
def reraise(tp, value, tb = ..., cause = ...) -> None: ...
def safe_kwarg(arg: _T0) -> _T0: ...
def u(s: _T0) -> _T0: ...
def ue(s: _T0) -> _T0: ...
def unquote(string: str, encoding: str = ..., errors: str = ...) -> str: ...
def unquote_plus(string: str, encoding: str = ..., errors: str = ...) -> str: ...
def with_metaclass(meta, *bases) -> Any: ...
def zip_longest(*p: Iterable, fillvalue = ...) -> Iterator: ...
