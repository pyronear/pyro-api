# (generated with --quick)

import __builtin__
import collections
import contextlib
import datetime
import functools
import io
import sqlalchemy.util._collections
import sqlalchemy.util.compat
from typing import Any, Callable, Dict, FrozenSet, Generator, Iterable, Iterator, List, NoReturn, Sequence, Set, Tuple, Type, TypeVar, Union

EMPTY_SET: FrozenSet[nothing]
EnsureKWArgType: Any
IdentitySet: Type[sqlalchemy.util._collections.IdentitySet]
ImmutableContainer: Type[sqlalchemy.util._collections.ImmutableContainer]
ImmutableProperties: Type[sqlalchemy.util._collections.ImmutableProperties]
KeyedTuple: Type[sqlalchemy.util._collections.KeyedTuple]
LRUCache: Type[sqlalchemy.util._collections.LRUCache]
MemoizedSlots: Any
NoneType: Any
OrderedDict: Type[sqlalchemy.util._collections.OrderedDict]
OrderedIdentitySet: Type[sqlalchemy.util._collections.OrderedIdentitySet]
OrderedProperties: Type[sqlalchemy.util._collections.OrderedProperties]
OrderedSet: Type[sqlalchemy.util._collections.OrderedSet]
PluginLoader: Any
PopulateDict: Type[sqlalchemy.util._collections.PopulateDict]
Properties: Type[sqlalchemy.util._collections.Properties]
ScopedRegistry: Type[sqlalchemy.util._collections.ScopedRegistry]
StringIO: Type[io.StringIO]
ThreadLocalRegistry: Type[sqlalchemy.util._collections.ThreadLocalRegistry]
UniqueAppender: Type[sqlalchemy.util._collections.UniqueAppender]
WeakPopulateDict: Type[sqlalchemy.util._collections.WeakPopulateDict]
WeakSequence: Type[sqlalchemy.util._collections.WeakSequence]
add_parameter_text: Any
arm: bool
as_interface: Any
asbool: Any
asint: Any
assert_arg_type: Any
attrsetter: Any
binary_type: Type[bytes]
bool_or_str: Any
byte_buffer: Type[io.BytesIO]
chop_traceback: Any
class_hierarchy: Any
classproperty: Any
clsname_as_plain_name: Any
coerce_kw_type: Any
collections_abc: module
column_dict: Type[dict]
column_set: Type[set]
constructor_copy: Any
counter: Any
cpython: bool
decode_slice: Any
decorator: Any
defaultdict: Type[collections.defaultdict]
dependencies: Any
deprecated: Any
deprecated_cls: Any
deprecated_params: Any
dictlike_iteritems: Any
duck_type_collection: Any
ellipses_string: Any
format_argspec_init: Any
format_argspec_plus: Any
generic_repr: Any
get_callable_argspec: Any
get_cls_kwargs: Any
get_func_kwargs: Any
getargspec_init: Any
group_expirable_memoized_property: Any
hybridmethod: Any
hybridproperty: Any
immutabledict: Type[sqlalchemy.util._collections.immutabledict]
inject_docstring_text: Any
int_types: Tuple[Type[int]]
iterate_attributes: Any
jython: bool
map_bits: Any
md5_hex: Any
memoized_instancemethod: Any
memoized_property: Any
methods_equivalent: Any
monkeypatch_proxied_specials: Any
nested: Callable[..., contextlib._GeneratorContextManager]
only_once: Any
ordered_column_set: Type[sqlalchemy.util._collections.OrderedSet]
osx: bool
partial: Type[functools.partial]
pending_deprecation: Any
pickle: module
portable_instancemethod: Any
print_: Any
py2k: bool
py33: bool
py36: bool
py3k: bool
pypy: bool
quoted_token_parser: Any
safe_reraise: Any
set_creation_order: Any
string_types: Tuple[Type[str]]
symbol: Any
text_type: Type[str]
threading: module
timezone: Type[datetime.timezone]
unbound_method_to_callable: Any
warn: Any
warn_deprecated: Any
warn_exception: Any
warn_limited: Any
warn_pending_deprecation: Any
win32: bool
wrap_callable: Any

AnyStr = TypeVar('AnyStr', str, bytes)
_S = TypeVar('_S')
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')

def b(s) -> Any: ...
def b64decode(x) -> bytes: ...
def b64encode(x) -> str: ...
def callable(obj) -> bool: ...
def cmp(a, b) -> Any: ...
def coerce_generator_arg(arg: _T0) -> Union[list, _T0]: ...
def contextmanager(func: Callable[..., Iterator[_T]]) -> Callable[..., contextlib._GeneratorContextManager[_T]]: ...
def decode_backslashreplace(text, encoding) -> Any: ...
def dottedgetter(*attrs: str) -> Callable[[Any], tuple]: ...
def flatten_iterator(x) -> Generator[Any, Any, __builtin__.NoneType]: ...
def has_dupes(sequence, target) -> bool: ...
def has_intersection(set_, iterable) -> bool: ...
def inspect_getfullargspec(func) -> sqlalchemy.util.compat.`namedtuple-FullArgSpec-args-varargs-varkw-defaults-kwonlyargs-kwonlydefaults-annotations`: ...
@overload
def iterbytes(collection: bytearray) -> bytearray_iterator: ...
@overload
def iterbytes(collection: Dict[_T, _T2]) -> Iterator[_T]: ...
@overload
def iterbytes(collection: Generator[_T]) -> Generator[_T]: ...
@overload
def iterbytes(collection: List[_T]) -> listiterator[_T]: ...
@overload
def iterbytes(collection: Set[_T]) -> setiterator[_T]: ...
@overload
def iterbytes(collection: Tuple[_T, ...]) -> tupleiterator[_T]: ...
@overload
def iterbytes(collection: Iterable[_T]) -> Iterator[_T]: ...
@overload
def iterbytes(func: Callable[[], Union[_T, _T2]], sentinel: _T) -> Iterator[_T2]: ...
def itertools_filter(function: Union[Callable[[_T], Any], __builtin__.NoneType], iterable: Iterable[_T]) -> Iterator[_T]: ...
def itertools_filterfalse(predicate: Union[Callable[[_T], object], __builtin__.NoneType], iterable: Iterable[_T]) -> Iterator[_T]: ...
def lightweight_named_tuple(name, fields) -> Any: ...
def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: Union[__builtin__.NoneType, bool] = ..., rename: Union[__builtin__.NoneType, bool] = ...) -> type: ...
def next(iterator: Iterator[_T], default: _T2 = ...) -> Union[_T, _T2]: ...
def parse_qsl(qs: Union[__builtin__.NoneType, AnyStr], keep_blank_values: Union[__builtin__.NoneType, bool] = ..., strict_parsing: Union[__builtin__.NoneType, bool] = ..., encoding: str = ..., errors: str = ..., max_num_fields: Union[__builtin__.NoneType, int] = ...) -> List[Tuple[AnyStr, AnyStr]]: ...
@overload
def quote_plus(string: str, safe: Union[bytes, str] = ..., encoding: Union[__builtin__.NoneType, str] = ..., errors: Union[__builtin__.NoneType, str] = ...) -> str: ...
@overload
def quote_plus(string: bytes, safe: Union[bytes, str] = ...) -> str: ...
def raise_(exception, with_traceback = ..., replace_context = ..., from_ = ...) -> NoReturn: ...
def raise_from_cause(exception, exc_info = ...) -> __builtin__.NoneType: ...
@overload
def reduce(function: Callable[[_T, _S], _T], sequence: Iterable[_S], initial: _T) -> _T: ...
@overload
def reduce(function: Callable[[_T, _T], _T], sequence: Iterable[_T]) -> _T: ...
def reraise(tp, value, tb = ..., cause = ...) -> __builtin__.NoneType: ...
def safe_kwarg(arg: _T0) -> _T0: ...
def to_column_set(x: _T0) -> Union[set, _T0]: ...
def to_list(x: _T0, default: _T1 = ...) -> Union[list, _T0, _T1]: ...
def to_set(x: _T0) -> Union[set, _T0]: ...
def u(s: _T0) -> _T0: ...
def ue(s: _T0) -> _T0: ...
def unique_list(seq, hashfunc = ...) -> Any: ...
def unquote(string: str, encoding: str = ..., errors: str = ...) -> str: ...
def unquote_plus(string: str, encoding: str = ..., errors: str = ...) -> str: ...
def update_copy(d, _new = ..., **kw) -> Any: ...
def update_wrapper(wrapper: Callable, wrapped: Callable, assigned: Sequence[str] = ..., updated: Sequence[str] = ...) -> Callable: ...
def with_metaclass(meta, *bases) -> Any: ...
def zip_longest(*p: Iterable, fillvalue = ...) -> Iterator: ...
