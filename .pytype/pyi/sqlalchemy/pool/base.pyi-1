# (generated with --quick)

import collections
import sqlalchemy.log
from typing import Any, Callable, NoReturn, Optional, Type, TypeVar, Union

_refs: set
deque: Type[collections.deque]
event: Any
exc: Any
interfaces: Any
log: module
reset_commit: Any
reset_none: Any
reset_rollback: Any
threading: Any
time: module
util: module
weakref: module

_T0 = TypeVar('_T0')

class Pool(sqlalchemy.log.Identified):
    __doc__: str
    __init__: Any
    _creator: Any
    _dialect: _ConnDialect
    _invalidate_time: float
    add_listener: Any
    def _close_connection(self, connection) -> None: ...
    def _create_connection(self) -> _ConnectionRecord: ...
    def _do_get(self) -> NoReturn: ...
    def _do_return_conn(self, conn) -> NoReturn: ...
    def _invalidate(self, connection, exception = ..., _checkin = ...) -> None: ...
    def _return_conn(self, record) -> None: ...
    def _should_wrap_creator(self, creator: _T0) -> Union[Callable[[Any], Any], _T0]: ...
    def connect(self) -> Any: ...
    def dispose(self) -> NoReturn: ...
    def recreate(self) -> NoReturn: ...
    def status(self) -> NoReturn: ...
    def unique_connection(self) -> Any: ...

class _ConnDialect:
    __doc__: str
    def do_close(self, dbapi_connection) -> None: ...
    def do_commit(self, dbapi_connection) -> None: ...
    def do_ping(self, dbapi_connection) -> NoReturn: ...
    def do_rollback(self, dbapi_connection) -> None: ...

class _ConnectionFairy:
    __doc__: str
    _connection_record: Any
    _counter: Any
    _echo: Any
    _logger: Any
    _reset_agent: None
    connection: Any
    info: Any
    is_valid: bool
    record_info: Any
    def __getattr__(self, key) -> Any: ...
    def __init__(self, dbapi_connection, connection_record, echo) -> None: ...
    def _checkin(self) -> None: ...
    @classmethod
    def _checkout(cls, pool, threadconns = ..., fairy = ...) -> Any: ...
    def _checkout_existing(self) -> Any: ...
    def _close(self) -> None: ...
    def _reset(self, pool) -> None: ...
    def close(self) -> None: ...
    def cursor(self, *args, **kwargs) -> Any: ...
    def detach(self) -> None: ...
    def invalidate(self, e = ..., soft = ...) -> None: ...

class _ConnectionRecord:
    _ConnectionRecord__pool: Any
    __doc__: str
    _soft_invalidate_time: Union[float, int]
    connection: Any
    fairy_ref: None
    finalize_callback: collections.deque
    in_use: bool
    info: Any
    last_connect_time: Any
    record_info: Any
    starttime: Optional[float]
    def _ConnectionRecord__close(self) -> None: ...
    def _ConnectionRecord__connect(self, first_connect_check = ...) -> None: ...
    def __init__(self, pool, connect = ...) -> None: ...
    def _checkin_failed(self, err) -> None: ...
    def checkin(self, _no_fairy_ref = ...) -> None: ...
    @classmethod
    def checkout(cls, pool) -> _ConnectionFairy: ...
    def close(self) -> None: ...
    def get_connection(self) -> Any: ...
    def invalidate(self, e = ..., soft = ...) -> None: ...

def _finalize_fairy(connection, connection_record, pool, ref, echo, fairy = ...) -> None: ...
