# (generated with --quick)

from typing import AbstractSet, Any, Callable, Iterable, List, Mapping, Optional, Sequence, Tuple

ATTRS_EQ_FIELD: str
_assertion_pass: Optional[Callable[[int, str, str], None]]
_pytest: module
_reprcompare: Optional[Callable[[str, Any, Any], Optional[str]]]
collections: module
outcomes: module
pprint: module

def _compare_eq_any(left, right, verbose: int = ...) -> List[str]: ...
def _compare_eq_cls(left, right, verbose: int, type_fns: Tuple[Callable[[Any], bool], Callable[[Any], bool]]) -> List[str]: ...
def _compare_eq_dict(left: Mapping, right: Mapping, verbose: int = ...) -> List[str]: ...
def _compare_eq_iterable(left: Iterable, right: Iterable, verbose: int = ...) -> List[str]: ...
def _compare_eq_sequence(left: Sequence, right: Sequence, verbose: int = ...) -> List[str]: ...
def _compare_eq_set(left: AbstractSet, right: AbstractSet, verbose: int = ...) -> List[str]: ...
def _compare_eq_verbose(left, right) -> List[str]: ...
def _diff_text(left: str, right: str, verbose: int = ...) -> List[str]: ...
def _format_lines(lines: Sequence[str]) -> List[str]: ...
def _notin_text(term: str, text: str, verbose: int = ...) -> List[str]: ...
def _pformat_dispatch(object: object, indent: int = ..., width: int = ..., depth: Optional[int] = ..., *, compact: bool = ...) -> str: ...
def _split_explanation(explanation: str) -> List[str]: ...
def _surrounding_parens_on_own_lines(lines: List[str]) -> None: ...
def assertrepr_compare(config, op: str, left, right) -> Optional[List[str]]: ...
def format_explanation(explanation: str) -> str: ...
def isattrs(obj) -> bool: ...
def isdatacls(obj) -> bool: ...
def isdict(x) -> bool: ...
def isiterable(obj) -> bool: ...
def issequence(x) -> bool: ...
def isset(x) -> bool: ...
def istext(x) -> bool: ...
def safeformat(obj: object) -> str: ...
def saferepr(obj: object, maxsize: int = ...) -> str: ...
