# (generated with --quick)

import _ast
import _pytest._code.source
import _weakref
import io
import pathlib
import types
import typing
from typing import Any, Callable, Dict, Iterable, List, Mapping, Optional, Sequence, Tuple, Type, TypeVar, Union

_TracebackStyle = typing.Literal

ATTRS_EQ_FIELD: str
CO_VARARGS: int
CO_VARKEYWORDS: int
CodeType: Type[types.CodeType]
ExceptionInfo: Any
FrameType: Type[types.FrameType]
Literal: Type[typing.Literal]
Path: Type[pathlib.Path]
ReferenceType: Type[_weakref.ReferenceType]
Source: Type[_pytest._code.source.Source]
StringIO: Type[io.StringIO]
TYPE_CHECKING: Any
TerminalWriter: module
TracebackType: Type[types.TracebackType]
_PLUGGY_DIR: pathlib.Path
_PYTEST_DIR: pathlib.Path
_PY_DIR: pathlib.Path
_pytest: module
attr: module
co_equal: code
final: Any
inspect: module
overload: Any
pluggy: module
py: module
re: module
ref: Type[_weakref.ReferenceType]
sys: module
traceback: module

_E = TypeVar('_E', bound=BaseException)
_TTraceback = TypeVar('_TTraceback', bound=Traceback)

class Code:
    __doc__: str
    __hash__: None
    filename: Any
    firstlineno: Any
    fullsource: Optional[_pytest._code.source.Source]
    name: Any
    path: Any
    raw: Any
    def __eq__(self, other) -> Any: ...
    def __init__(self, rawcode) -> None: ...
    def getargs(self, var: bool = ...) -> Tuple[str, ...]: ...
    def source(self) -> _pytest._code.source.Source: ...

class ExceptionChainRepr(ExceptionRepr):
    chain: Sequence[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]
    def __attrs_post_init__(self) -> None: ...
    def __init__(self, chain: Sequence[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]) -> None: ...
    def toterminal(self, tw) -> None: ...

class ExceptionRepr(TerminalRepr):
    reprcrash: Any
    reprtraceback: Any
    def __attrs_post_init__(self) -> None: ...
    def __init__(self) -> None: ...
    def addsection(self, name: str, content: str, sep: str = ...) -> None: ...
    def toterminal(self, tw) -> None: ...

class FormattedExcinfo:
    __doc__: str
    abspath: bool
    astcache: dict
    chain: bool
    fail_marker: str
    flow_marker: str
    funcargs: bool
    showlocals: bool
    style: typing.Literal
    tbfilter: bool
    truncate_locals: bool
    def __init__(self, showlocals: bool = ..., style: typing.Literal = ..., abspath: bool = ..., tbfilter: bool = ..., funcargs: bool = ..., truncate_locals: bool = ..., chain: bool = ...) -> None: ...
    def _getentrysource(self, entry: TracebackEntry) -> Optional[_pytest._code.source.Source]: ...
    def _getindent(self, source: _pytest._code.source.Source) -> int: ...
    def _makepath(self, path) -> Any: ...
    def _truncate_recursive_traceback(self, traceback: Traceback) -> Tuple[Traceback, Optional[str]]: ...
    def get_exconly(self, excinfo, indent: int = ..., markall: bool = ...) -> List[str]: ...
    def get_source(self, source: Optional[_pytest._code.source.Source], line_index: int = ..., excinfo = ..., short: bool = ...) -> List[str]: ...
    def repr_args(self, entry: TracebackEntry) -> Optional[ReprFuncArgs]: ...
    def repr_excinfo(self, excinfo) -> ExceptionChainRepr: ...
    def repr_locals(self, locals: Mapping[str, object]) -> Optional[ReprLocals]: ...
    def repr_traceback(self, excinfo) -> ReprTraceback: ...
    def repr_traceback_entry(self, entry: TracebackEntry, excinfo = ...) -> ReprEntry: ...

class Frame:
    __doc__: str
    code: Code
    f_globals: Dict[str, Any]
    f_locals: Dict[str, Any]
    lineno: int
    raw: types.FrameType
    statement: _pytest._code.source.Source
    def __init__(self, frame: types.FrameType) -> None: ...
    def eval(self, code, **vars) -> Any: ...
    def getargs(self, var: bool = ...) -> List[Tuple[Any, Any]]: ...
    def repr(self, object: object) -> str: ...

class ReprEntry(TerminalRepr):
    lines: Sequence[str]
    reprfileloc: Optional[ReprFileLocation]
    reprfuncargs: Optional[ReprFuncArgs]
    reprlocals: Optional[ReprLocals]
    style: typing.Literal
    def __init__(self, lines: Sequence[str], reprfuncargs: Optional[ReprFuncArgs], reprlocals: Optional[ReprLocals], reprfileloc: Optional[ReprFileLocation], style: typing.Literal) -> None: ...
    def __str__(self) -> str: ...
    def _write_entry_lines(self, tw) -> None: ...
    def toterminal(self, tw) -> None: ...

class ReprEntryNative(TerminalRepr):
    lines: Sequence[str]
    style: typing.Literal
    def __init__(self, lines: Sequence[str]) -> None: ...
    def toterminal(self, tw) -> None: ...

class ReprExceptionInfo(ExceptionRepr):
    reprcrash: ReprFileLocation
    reprtraceback: ReprTraceback
    def __init__(self, reprtraceback: ReprTraceback, reprcrash: ReprFileLocation) -> None: ...
    def toterminal(self, tw) -> None: ...

class ReprFileLocation(TerminalRepr):
    lineno: int
    message: str
    path: str
    def __init__(self, path: str, lineno: int, message: str) -> None: ...
    def toterminal(self, tw) -> None: ...

class ReprFuncArgs(TerminalRepr):
    args: Sequence[Tuple[str, Any]]
    def __init__(self, args: Sequence[Tuple[str, object]]) -> None: ...
    def toterminal(self, tw) -> None: ...

class ReprLocals(TerminalRepr):
    lines: Sequence[str]
    def __init__(self, lines: Sequence[str]) -> None: ...
    def toterminal(self, tw, indent = ...) -> None: ...

class ReprTraceback(TerminalRepr):
    entrysep: str
    extraline: Optional[str]
    reprentries: Sequence[Union[ReprEntry, ReprEntryNative]]
    style: typing.Literal
    def __init__(self, reprentries: Sequence[Union[ReprEntry, ReprEntryNative]], extraline: Optional[str], style: typing.Literal) -> None: ...
    def toterminal(self, tw) -> None: ...

class ReprTracebackNative(ReprTraceback):
    extraline: None
    reprentries: List[ReprEntryNative]
    style: str
    def __init__(self, tblines: Sequence[str]) -> None: ...

class TerminalRepr:
    def __init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def toterminal(self, tw) -> None: ...

class Traceback(List[TracebackEntry]):
    __doc__: str
    _excinfo: Optional[_weakref.ReferenceType]
    def __getitem__(self, key: Union[int, slice]) -> Union[Traceback, TracebackEntry]: ...
    def __init__(self, tb: Union[types.TracebackType, Iterable[TracebackEntry]], excinfo: Optional[_weakref.ReferenceType] = ...) -> None: ...
    def cut(self: _TTraceback, path = ..., lineno: Optional[int] = ..., firstlineno: Optional[int] = ..., excludepath = ...) -> _TTraceback: ...
    def filter(self: _TTraceback, fn: Callable[[TracebackEntry], bool] = ...) -> _TTraceback: ...
    def getcrashentry(self) -> TracebackEntry: ...
    def recursionindex(self) -> Optional[int]: ...

class TracebackEntry:
    __doc__: str
    _excinfo: Any
    _rawentry: types.TracebackType
    _repr_style: Optional[typing.Literal]
    exprinfo: None
    frame: Frame
    lineno: int
    locals: Dict[str, Any]
    name: str
    path: Any
    relline: int
    source: Optional[_pytest._code.source.Source]
    statement: _pytest._code.source.Source
    def __init__(self, rawentry: types.TracebackType, excinfo: Optional[_weakref.ReferenceType] = ...) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def getfirstlinesource(self) -> int: ...
    def getsource(self, astcache = ...) -> Optional[_pytest._code.source.Source]: ...
    def ishidden(self) -> bool: ...
    def set_repr_style(self, mode: typing.Literal) -> None: ...

def filter_traceback(entry: TracebackEntry) -> bool: ...
def findsource(obj) -> Tuple[Optional[_pytest._code.source.Source], int]: ...
def format_exception_only(etype: Optional[Type[BaseException]], value: Optional[BaseException]) -> List[str]: ...
def get_real_func(obj) -> Any: ...
def getfslineno(obj: object) -> Tuple[Any, int]: ...
def getrawcode(obj, trycall: bool = ...) -> Any: ...
def getstatementrange_ast(lineno: int, source: _pytest._code.source.Source, assertion: bool = ..., astnode: Optional[_ast.AST] = ...) -> Tuple[_ast.AST, int, int]: ...
def safeformat(obj: object) -> str: ...
def saferepr(obj: object, maxsize: int = ...) -> str: ...
