# (generated with --quick)

import __future__
from typing import Any, BinaryIO, Callable, Dict, Generator, Iterable, List, Match, NoReturn, Optional, Pattern, Sized, Tuple, Type, TypeVar, Union

AvailableDistributions = Environment

BINARY_DIST: int
CHECKOUT_DIST: int
DEVELOP_DIST: int
EGG_DIST: int
FileExistsError: Type[OSError]
NotADirectoryError: None
PY_MAJOR: str
PermissionError: None
SOURCE_DIST: int
WRITE_SUPPORT: bool
__all__: list
__metaclass__: Type[type]
_distributionImpl: Dict[str, Type[Distribution]]
_distribution_finders: None
_imp: module
_namespace_handlers: None
_namespace_packages: None
_provider_factories: dict
_state_vars: Dict[str, Any]
absolute_import: __future__._Feature
add_activation_listener: None
appdirs: Any
cleanup_resources: None
collections: module
darwinVersionString: Pattern[str]
email: module
empty_provider: EmptyProvider
errno: module
filter: Any
functools: module
importlib_machinery: Optional[module]
inspect: module
io: module
iter_entry_points: None
itertools: module
macosVersionString: Pattern[str]
map: Any
ntpath: module
operator: module
os: module
packaging: Any
pkgutil: module
platform: module
plistlib: module
posixpath: module
py31compat: module
re: module
require: None
resource_dir: None
resource_exists: None
resource_filename: None
resource_isdir: None
resource_listdir: None
resource_stream: None
resource_string: None
resources_stream: None
set_extraction_path: None
six: Any
stat: module
sys: module
tempfile: module
textwrap: module
time: module
types: module
warnings: module
working_set: None
zipfile: module
zipimport: module

AnyStr = TypeVar('AnyStr', str, bytes)
_T0 = TypeVar('_T0')
_TDistribution = TypeVar('_TDistribution', bound=Distribution)
_TEggInfoDistribution = TypeVar('_TEggInfoDistribution', bound=EggInfoDistribution)
_TEntryPoint = TypeVar('_TEntryPoint', bound=EntryPoint)
_TEnvironment = TypeVar('_TEnvironment', bound=Environment)
_TWorkingSet = TypeVar('_TWorkingSet', bound=WorkingSet)
_Tnamedtuple-manifest_mod-manifest-mtime = TypeVar('_Tnamedtuple-manifest_mod-manifest-mtime', bound=`namedtuple-manifest_mod-manifest-mtime`)

class ContextualVersionConflict(VersionConflict):
    __doc__: str
    _template: str
    required_by: Any

class DefaultProvider(EggProvider):
    __doc__: str
    loader: Any
    module_path: Any
    def _get(self, path) -> bytes: ...
    def _has(self, path) -> bool: ...
    def _isdir(self, path) -> bool: ...
    def _listdir(self, path) -> list: ...
    @classmethod
    def _register(cls) -> None: ...
    def get_resource_stream(self, manager, resource_name) -> BinaryIO: ...

class DistInfoDistribution(Distribution):
    EQEQ: Pattern[str]
    PKG_INFO: str
    _DistInfoDistribution__dep_map: Dict[Any, list]
    __doc__: str
    _dep_map: Any
    _parsed_pkg_info: Any
    _provider: Any
    _version: Any
    location: Any
    platform: Any
    precedence: Any
    project_name: Any
    py_version: Any
    def _compute_dependencies(self) -> Dict[Any, list]: ...

class Distribution:
    PKG_INFO: str
    __dir__: Any
    __doc__: str
    _dep_map: Any
    _ep_map: Any
    _provider: Any
    _version: Any
    extras: Any
    hashcmp: Tuple[Any, Any, Any, Any, Any, Any]
    key: Any
    location: Any
    parsed_version: Any
    platform: Any
    precedence: Any
    project_name: Any
    py_version: Any
    version: Any
    def __eq__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getattr__(self, attr) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __hash__(self) -> int: ...
    def __init__(self, location = ..., metadata = ..., project_name = ..., version = ..., py_version = ..., platform = ..., precedence = ...) -> None: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def _build_dep_map(self) -> Dict[Any, list]: ...
    @staticmethod
    def _filter_extras(dm: _T0) -> _T0: ...
    def _get_metadata(self, name) -> Generator[Any, Any, None]: ...
    def _get_metadata_path_for_display(self, name) -> Any: ...
    def _get_version(self) -> Any: ...
    def _reload_version(self: _TDistribution) -> _TDistribution: ...
    def _warn_legacy_version(self) -> None: ...
    def activate(self, path = ..., replace = ...) -> None: ...
    def as_requirement(self) -> Any: ...
    def check_version_conflict(self) -> None: ...
    def clone(self: _TDistribution, **kw) -> _TDistribution: ...
    def egg_name(self) -> str: ...
    @classmethod
    def from_filename(cls, filename, metadata = ..., **kw) -> Any: ...
    @classmethod
    def from_location(cls, location, basename, metadata = ..., **kw) -> Any: ...
    def get_entry_info(self, group, name) -> Any: ...
    def get_entry_map(self, group = ...) -> Any: ...
    def has_version(self) -> bool: ...
    def insert_on(self, path, loc = ..., replace = ...) -> None: ...
    def load_entry_point(self, group, name) -> Any: ...
    def requires(self, extras = ...) -> list: ...

class DistributionNotFound(ResolutionError):
    __doc__: str
    _template: str
    req: Any
    requirers: Any
    requirers_str: str
    def __str__(self) -> Any: ...
    def report(self) -> str: ...

class EggInfoDistribution(Distribution):
    _provider: Any
    _version: Any
    location: Any
    platform: Any
    precedence: Any
    project_name: Any
    py_version: Any
    def _reload_version(self: _TEggInfoDistribution) -> _TEggInfoDistribution: ...

class EggMetadata(ZipProvider):
    __doc__: str
    egg_info: Any
    loader: Any
    module_path: Any
    zip_pre: Any
    def __init__(self, importer) -> None: ...

class EggProvider(NullProvider):
    __doc__: str
    egg_info: str
    egg_name: Any
    egg_root: Any
    loader: Any
    module_path: Any
    def __init__(self, module) -> None: ...
    def _set_egg(self, path) -> None: ...
    def _setup_prefix(self) -> None: ...

class EmptyProvider(NullProvider):
    __doc__: str
    module_path: None
    def __init__(self) -> None: ...
    def _get(self, path) -> str: ...
    def _has(self, path) -> bool: ...
    def _isdir(self, path) -> bool: ...
    def _listdir(self, path) -> List[nothing]: ...

class EntryPoint:
    __doc__: str
    attrs: tuple
    dist: Any
    extras: tuple
    module_name: Any
    name: Any
    pattern: Pattern[str]
    def __init__(self, name, module_name, attrs = ..., extras = ..., dist = ...) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    @classmethod
    def _parse_extras(cls, extras_spec) -> Any: ...
    def load(self, require = ..., *args, **kwargs) -> Any: ...
    @classmethod
    def parse(cls: Type[_TEntryPoint], src, dist = ...) -> _TEntryPoint: ...
    @classmethod
    def parse_group(cls, group, lines, dist = ...) -> dict: ...
    @classmethod
    def parse_map(cls, data, dist = ...) -> dict: ...
    def require(self, env = ..., installer = ...) -> None: ...
    def resolve(self) -> Any: ...

class Environment:
    __doc__: str
    _distmap: Dict[Any, list]
    platform: Any
    python: Any
    def __add__(self, other) -> Any: ...
    def __getitem__(self, project_name) -> list: ...
    def __iadd__(self: _TEnvironment, other) -> _TEnvironment: ...
    def __init__(self, search_path = ..., platform = ..., python = ...) -> None: ...
    def __iter__(self) -> Generator[Any, Any, None]: ...
    def add(self, dist) -> None: ...
    def best_match(self, req, working_set, installer = ..., replace_conflicting = ...) -> Any: ...
    def can_add(self, dist) -> Any: ...
    def obtain(self, requirement, installer = ...) -> Any: ...
    def remove(self, dist) -> None: ...
    def scan(self, search_path = ...) -> None: ...

class ExtractionError(RuntimeError):
    __doc__: str
    cache_path: Any
    manager: ResourceManager
    original_error: Optional[BaseException]

class FileMetadata(EmptyProvider):
    __doc__: str
    path: Any
    def __init__(self, path) -> None: ...
    def _get_metadata_path(self, name) -> Any: ...
    def _warn_on_replacement(self, metadata) -> None: ...
    def get_metadata(self, name) -> str: ...
    def get_metadata_lines(self, name) -> Any: ...
    def has_metadata(self, name) -> Any: ...

class IMetadataProvider:
    def get_metadata(name: IMetadataProvider) -> None: ...
    def get_metadata_lines(name: IMetadataProvider) -> None: ...
    def has_metadata(name: IMetadataProvider) -> None: ...
    def metadata_isdir(name: IMetadataProvider) -> None: ...
    def metadata_listdir(name: IMetadataProvider) -> None: ...
    def run_script(script_name: IMetadataProvider, namespace) -> None: ...

class IResourceProvider(IMetadataProvider):
    __doc__: str
    def get_resource_filename(manager: IResourceProvider, resource_name) -> None: ...
    def get_resource_stream(manager: IResourceProvider, resource_name) -> None: ...
    def get_resource_string(manager: IResourceProvider, resource_name) -> None: ...
    def has_resource(resource_name: IResourceProvider) -> None: ...
    def resource_isdir(resource_name: IResourceProvider) -> None: ...
    def resource_listdir(resource_name: IResourceProvider) -> None: ...

class MemoizedZipManifests(ZipManifests):
    __doc__: str
    manifest_mod: Type[`namedtuple-manifest_mod-manifest-mtime`]
    def load(self, path) -> Any: ...

class NoDists:
    __doc__: str
    def __bool__(self) -> bool: ...
    def __call__(self, fullpath) -> tupleiterator[nothing]: ...
    def __nonzero__(self) -> bool: ...

class NullProvider:
    __doc__: str
    egg_info: None
    egg_name: None
    loader: Any
    module_path: Any
    def __init__(self, module) -> None: ...
    def _fn(self, base, resource_name) -> Any: ...
    def _get(self, path) -> Any: ...
    def _get_metadata_path(self, name) -> Any: ...
    def _has(self, path) -> NoReturn: ...
    def _isdir(self, path) -> NoReturn: ...
    def _listdir(self, path) -> NoReturn: ...
    @staticmethod
    def _validate_resource_path(path) -> None: ...
    def get_metadata(self, name) -> Any: ...
    def get_metadata_lines(self, name) -> Any: ...
    def get_resource_filename(self, manager, resource_name) -> Any: ...
    def get_resource_stream(self, manager, resource_name) -> io.BytesIO: ...
    def get_resource_string(self, manager, resource_name) -> Any: ...
    def has_metadata(self, name) -> Any: ...
    def has_resource(self, resource_name) -> Any: ...
    def metadata_isdir(self, name) -> Any: ...
    def metadata_listdir(self, name) -> Any: ...
    def resource_isdir(self, resource_name) -> Any: ...
    def resource_listdir(self, resource_name) -> Any: ...
    def run_script(self, script_name, namespace) -> None: ...

class PEP440Warning(RuntimeWarning):
    __doc__: str

class PathMetadata(DefaultProvider):
    __doc__: str
    egg_info: Any
    module_path: Any
    def __init__(self, path, egg_info) -> None: ...

class PkgResourcesDeprecationWarning(Warning):
    __doc__: str

class Requirement(Any):
    _Requirement__hash: int
    extras: tuple
    hashCmp: Tuple[Any, Any, Any, frozenset, Optional[str]]
    key: Any
    project_name: Any
    specs: Any
    unsafe_name: Any
    def __contains__(self, item) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __init__(self, requirement_string) -> None: ...
    def __ne__(self, other) -> bool: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def parse(s) -> Any: ...

class RequirementParseError(ValueError):
    def __str__(self) -> str: ...

class ResolutionError(Exception):
    __doc__: str
    def __repr__(self) -> str: ...

class ResourceManager:
    __doc__: str
    cached_files: Dict[Any, int]
    extraction_path: Any
    def __init__(self) -> None: ...
    @staticmethod
    def _warn_unsafe_extraction_path(path) -> None: ...
    def cleanup_resources(self, force = ...) -> None: ...
    def extraction_error(self) -> NoReturn: ...
    def get_cache_path(self, archive_name, names = ...) -> Any: ...
    def postprocess(self, tempname, filename) -> None: ...
    def resource_exists(self, package_or_requirement, resource_name) -> Any: ...
    def resource_filename(self, package_or_requirement, resource_name) -> Any: ...
    def resource_isdir(self, package_or_requirement, resource_name) -> Any: ...
    def resource_listdir(self, package_or_requirement, resource_name) -> Any: ...
    def resource_stream(self, package_or_requirement, resource_name) -> Any: ...
    def resource_string(self, package_or_requirement, resource_name) -> Any: ...
    def set_extraction_path(self, path) -> None: ...

class UnknownExtra(ResolutionError):
    __doc__: str

class VersionConflict(ResolutionError):
    __doc__: str
    _template: str
    dist: Any
    req: Any
    def report(self) -> str: ...
    def with_context(self, required_by) -> VersionConflict: ...

class WorkingSet:
    __doc__: str
    by_key: Any
    callbacks: Any
    entries: Any
    entry_keys: Any
    def __contains__(self, dist) -> bool: ...
    def __getstate__(self) -> Tuple[List[nothing], Dict[nothing, nothing], Dict[nothing, nothing], List[nothing]]: ...
    def __init__(self, entries = ...) -> None: ...
    def __iter__(self) -> Generator[nothing, Any, None]: ...
    def __setstate__(self, e_k_b_c) -> None: ...
    def _added_new(self, dist) -> None: ...
    @classmethod
    def _build_from_requirements(cls: Type[_TWorkingSet], req_spec) -> _TWorkingSet: ...
    @classmethod
    def _build_master(cls: Type[_TWorkingSet]) -> _TWorkingSet: ...
    def add(self, dist, entry = ..., insert = ..., replace = ...) -> None: ...
    def add_entry(self, entry) -> None: ...
    def find(self, req) -> Any: ...
    def find_plugins(self, plugin_env, full_env = ..., installer = ..., fallback = ...) -> Tuple[list, Dict[Any, ResolutionError]]: ...
    def iter_entry_points(self, group, name = ...) -> Any: ...
    def require(self, *requirements) -> Any: ...
    def resolve(self, requirements, env = ..., installer = ..., replace_conflicting = ..., extras = ...) -> list: ...
    def run_script(self, requires, script_name) -> None: ...
    def subscribe(self, callback, existing = ...) -> None: ...

class ZipManifests(dict):
    __doc__: str
    @classmethod
    def build(cls, path) -> dict: ...
    @classmethod
    def load(cls, path) -> dict: ...

class ZipProvider(EggProvider):
    __doc__: str
    _dirindex: Dict[str, list]
    _zip_manifests: MemoizedZipManifests
    eagers: Optional[list]
    loader: Any
    module_path: Any
    zip_pre: Any
    zipinfo: Any
    def __init__(self, module) -> None: ...
    def _eager_to_zip(self, resource_name) -> Any: ...
    def _extract_resource(self, manager, zip_path) -> Any: ...
    @staticmethod
    def _get_date_and_size(zip_stat) -> Tuple[float, Any]: ...
    def _get_eager_resources(self) -> list: ...
    def _has(self, fspath) -> bool: ...
    def _index(self) -> Any: ...
    def _is_current(self, file_path, zip_path) -> Any: ...
    def _isdir(self, fspath) -> bool: ...
    def _listdir(self, fspath) -> list: ...
    def _parts(self, zip_path) -> Any: ...
    def _resource_to_zip(self, resource_name) -> Any: ...
    def _zipinfo_name(self, fspath) -> Any: ...
    def get_resource_filename(self, manager, resource_name) -> Any: ...

class _ReqExtras(dict):
    __doc__: str
    def markers_pass(self, req, extras = ...) -> bool: ...

class `namedtuple-manifest_mod-manifest-mtime`(tuple):
    __slots__ = ["manifest", "mtime"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str]
    manifest: Any
    mtime: Any
    def __getnewargs__(self) -> Tuple[Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-manifest_mod-manifest-mtime`], manifest, mtime) -> `_Tnamedtuple-manifest_mod-manifest-mtime`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-manifest_mod-manifest-mtime`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-manifest_mod-manifest-mtime`: ...
    def _replace(self: `_Tnamedtuple-manifest_mod-manifest-mtime`, **kwds) -> `_Tnamedtuple-manifest_mod-manifest-mtime`: ...

def EGG_NAME(string: AnyStr, pos: int = ..., endpos: int = ...) -> Match[AnyStr]: ...
def MODULE(string: AnyStr, pos: int = ..., endpos: int = ...) -> Match[AnyStr]: ...
def __getstate__() -> Dict[str, Any]: ...
def __setstate__(state: _T0) -> _T0: ...
def _always_object(classes) -> Any: ...
def _by_version_descending(names) -> list: ...
def _bypass_ensure_directory(path) -> None: ...
def _call_aside(f: _T0, *args, **kwargs) -> _T0: ...
def _cygwin_patch(filename) -> Any: ...
def _declare_state(vartype, **kw) -> None: ...
def _find_adapter(registry, ob) -> Any: ...
def _handle_ns(packageName, path_item) -> Any: ...
def _initialize(g = ...) -> None: ...
def _initialize_master_working_set() -> None: ...
def _is_egg_path(path) -> Any: ...
def _is_unpacked_egg(path) -> Any: ...
def _macos_arch(machine: _T0) -> Union[str, _T0]: ...
def _macos_vers(_cache = ...) -> Any: ...
def _mkstemp(*args, **kw) -> Tuple[int, Any]: ...
def _normalize_cached(filename, _cache = ...) -> Any: ...
def _parents(path: _T0) -> Generator[_T0, Any, None]: ...
def _rebuild_mod_path(orig_path, package_name, module) -> None: ...
def _set_parent_ns(packageName) -> None: ...
def _sget_dict(val) -> Any: ...
def _sget_none(*args) -> None: ...
def _sget_object(val) -> Any: ...
def _sset_dict(key, ob, state) -> None: ...
def _sset_none(*args) -> None: ...
def _sset_object(key, ob, state) -> None: ...
def _version_from_file(lines) -> Any: ...
def compatible_platforms(provided, required) -> bool: ...
def declare_namespace(packageName) -> None: ...
def dist_factory(path_item, entry, only) -> Union[NoDists, Callable]: ...
def distributions_from_metadata(path) -> Generator[Any, Any, None]: ...
def ensure_directory(path) -> None: ...
def evaluate_marker(text, extra = ...) -> Any: ...
def file_ns_handler(importer, path_item, packageName, module) -> Any: ...
def find_distributions(path_item, only = ...) -> Any: ...
def find_eggs_in_zip(importer, path_item, only = ...) -> Generator[Any, Any, None]: ...
def find_nothing(importer, path_item, only = ...) -> Tuple[()]: ...
def find_on_path(importer, path_item, only = ...) -> Generator[Any, Any, None]: ...
def fixup_namespace_packages(path_item, parent = ...) -> None: ...
def get_build_platform() -> str: ...
def get_default_cache() -> Any: ...
def get_distribution(dist) -> Any: ...
def get_entry_info(dist, group, name) -> Any: ...
def get_entry_map(dist, group = ...) -> Any: ...
def get_importer(path_item: str) -> Any: ...
def get_platform() -> str: ...
def get_provider(moduleOrReq) -> Any: ...
def get_supported_platform() -> str: ...
def invalid_marker(text) -> Union[SyntaxError, bool]: ...
def isdir(s: Union[_PathLike, bytes, str]) -> bool: ...
def issue_warning(*args, **kw) -> None: ...
def load_entry_point(dist, group, name) -> Any: ...
def mkdir(path: Union[_PathLike, bytes, str], mode: int = ..., *, dir_fd: Optional[int] = ...) -> None: ...
def non_empty_lines(path) -> Generator[str, Any, None]: ...
def normalize_path(filename) -> Any: ...
def null_ns_handler(importer, path_item, packageName, module) -> None: ...
def os_open(path: Union[_PathLike, bytes, str], flags: int, mode: int = ..., *, dir_fd: Optional[int] = ...) -> int: ...
def parse_requirements(strs) -> Generator[Requirement, Any, None]: ...
def parse_version(v) -> Any: ...
def register_finder(importer_type, distribution_finder) -> None: ...
def register_loader_type(loader_type, provider_factory) -> None: ...
def register_namespace_handler(importer_type, namespace_handler) -> None: ...
def rename(src: Union[_PathLike, bytes, str], dst: Union[_PathLike, bytes, str], *, src_dir_fd: Optional[int] = ..., dst_dir_fd: Optional[int] = ...) -> None: ...
def resolve_egg_link(path) -> Any: ...
def run_main(dist_spec, script_name) -> None: ...
def run_script(dist_spec, script_name) -> None: ...
def safe_extra(extra) -> str: ...
def safe_listdir(path) -> Union[list, Tuple[()]]: ...
def safe_name(name) -> str: ...
def safe_version(version) -> str: ...
def split(p: Union[_PathLike[AnyStr], AnyStr]) -> Tuple[AnyStr, AnyStr]: ...
def split_sections(s) -> Generator[Tuple[Any, list], Any, None]: ...
def to_filename(name) -> Any: ...
def unlink(path: Union[_PathLike, bytes, str], *, dir_fd: Optional[int] = ...) -> None: ...
def utime(path: Union[_PathLike, bytes, int, str], times: Optional[Tuple[float, float]] = ..., *, ns: Tuple[int, int] = ..., dir_fd: Optional[int] = ..., follow_symlinks: bool = ...) -> None: ...
def yield_lines(strs) -> Generator[Any, Any, None]: ...
