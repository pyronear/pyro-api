# (generated with --quick)

import ecdsa.curves
import ecdsa.ecdsa
import ecdsa.ellipticcurve
import ecdsa.numbertheory
import ecdsa.util
import hashlib
from typing import Any, List, Optional, Tuple, Type, TypeVar

MalformedSignature: Type[ecdsa.util.MalformedSignature]
NIST192p: ecdsa.curves.Curve
PY3: bool
RSZeroError: Type[ecdsa.ecdsa.RSZeroError]
SquareRootError: Type[ecdsa.numbertheory.SquareRootError]
__all__: List[str]
binascii: module
der: module
ecdsa: module
ellipticcurve: module
encoded_oid_ecPublicKey: bytes
oid_ecPublicKey: Tuple[int, int, int, int, int, int]
rfc6979: module

_TSigningKey = TypeVar('_TSigningKey', bound=SigningKey)
_TVerifyingKey = TypeVar('_TVerifyingKey', bound=VerifyingKey)

class BadDigestError(Exception):
    __doc__: str

class BadSignatureError(Exception):
    __doc__: str

class MalformedPointError(AssertionError):
    __doc__: str

class SigningKey:
    __doc__: str
    baselen: Any
    curve: Any
    default_hashfunc: Any
    privkey: Optional[ecdsa.ecdsa.Private_key]
    verifying_key: Any
    def __init__(self, _error__please_use_generate = ...) -> None: ...
    @classmethod
    def from_der(cls, string, hashfunc = ...) -> Any: ...
    @classmethod
    def from_pem(cls, string, hashfunc = ...) -> Any: ...
    @classmethod
    def from_secret_exponent(cls: Type[_TSigningKey], secexp, curve = ..., hashfunc = ...) -> _TSigningKey: ...
    @classmethod
    def from_string(cls, string, curve = ..., hashfunc = ...) -> Any: ...
    @classmethod
    def generate(cls, curve = ..., entropy = ..., hashfunc = ...) -> Any: ...
    def get_verifying_key(self) -> Any: ...
    def sign(self, data, entropy = ..., hashfunc = ..., sigencode = ..., k = ...) -> Any: ...
    def sign_deterministic(self, data, hashfunc = ..., sigencode = ..., extra_entropy = ...) -> Any: ...
    def sign_digest(self, digest, entropy = ..., sigencode = ..., k = ...) -> Any: ...
    def sign_digest_deterministic(self, digest, hashfunc = ..., sigencode = ..., extra_entropy = ...) -> Any: ...
    def sign_number(self, number, entropy = ..., k = ...) -> Tuple[Any, Any]: ...
    def to_der(self, point_encoding = ...) -> Any: ...
    def to_pem(self, point_encoding = ...) -> Any: ...
    def to_string(self) -> bytes: ...

class VerifyingKey:
    __doc__: str
    curve: Any
    default_hashfunc: Any
    pubkey: Optional[ecdsa.ecdsa.Public_key]
    def __init__(self, _error__please_use_generate = ...) -> None: ...
    def __repr__(self) -> str: ...
    def _compressed_encode(self) -> Any: ...
    @staticmethod
    def _from_compressed(string, curve, validate_point) -> ecdsa.ellipticcurve.Point: ...
    @classmethod
    def _from_hybrid(cls, string, curve, validate_point) -> Any: ...
    @staticmethod
    def _from_raw_encoding(string, curve, validate_point) -> ecdsa.ellipticcurve.Point: ...
    def _hybrid_encode(self) -> Any: ...
    def _raw_encode(self) -> bytes: ...
    @classmethod
    def from_der(cls, string) -> Any: ...
    @classmethod
    def from_pem(cls, string) -> Any: ...
    @classmethod
    def from_public_key_recovery(cls, signature, data, curve, hashfunc = ..., sigdecode = ...) -> Any: ...
    @classmethod
    def from_public_key_recovery_with_digest(cls, signature, digest, curve, hashfunc = ..., sigdecode = ...) -> Any: ...
    @classmethod
    def from_public_point(cls: Type[_TVerifyingKey], point, curve = ..., hashfunc = ...) -> _TVerifyingKey: ...
    @classmethod
    def from_string(cls, string, curve = ..., hashfunc = ..., validate_point = ...) -> Any: ...
    def to_der(self, point_encoding = ...) -> Any: ...
    def to_pem(self, point_encoding = ...) -> Any: ...
    def to_string(self, encoding = ...) -> Any: ...
    def verify(self, signature, data, hashfunc = ..., sigdecode = ...) -> Any: ...
    def verify_digest(self, signature, digest, sigdecode = ...) -> bool: ...

def b(s) -> Any: ...
def find_curve(oid_curve) -> ecdsa.curves.Curve: ...
def normalise_bytes(buffer_object) -> Any: ...
def number_to_string(num, order) -> bytes: ...
def randrange(order, entropy = ...) -> Any: ...
def sha1(string: bytes = ...) -> hashlib._Hash: ...
def sigdecode_string(signature, order) -> Tuple[Any, Any]: ...
def sigencode_string(r, s, order) -> Any: ...
def square_root_mod_prime(a, p) -> Any: ...
def string_to_number(string) -> int: ...
