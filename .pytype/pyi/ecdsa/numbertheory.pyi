# (generated with --quick)

import __future__
from typing import Any, Callable, Iterable, List, Tuple, Type, TypeVar

PY3: bool
division: __future__._Feature
integer_types: Tuple[Type[int]]
math: module
miller_rabin_test_count: int
smallprimes: List[int]
warnings: module
xrange: Type[range]

_S = TypeVar('_S')
_T = TypeVar('_T')
_T1 = TypeVar('_T1')

class Error(Exception):
    __doc__: str

class NegativeExponentError(Error): ...

class SquareRootError(Error): ...

def carmichael(n) -> Any: ...
def carmichael_of_factorized(f_list) -> Any: ...
def carmichael_of_ppower(pp) -> Any: ...
def factorization(n) -> List[Tuple[Any, int]]: ...
def gcd(*a) -> Any: ...
@overload
def gcd2(__x: int, __y: int) -> int: ...
@overload
def gcd2(a, b: _T1) -> _T1: ...
def inverse_mod(a, m) -> Any: ...
def is_prime(n) -> bool: ...
def jacobi(a, n) -> Any: ...
def kinda_order_mod(x, m) -> Any: ...
def largest_factor_relatively_prime(a, b) -> Any: ...
def lcm(*a) -> Any: ...
def lcm2(a, b) -> Any: ...
def modular_exp(base, exponent, modulus) -> Any: ...
def next_prime(starting_value) -> Any: ...
def order_mod(x, m) -> int: ...
def phi(n) -> Any: ...
def polynomial_exp_mod(base, exponent, polymod, p) -> Any: ...
def polynomial_multiply_mod(m1, m2, polymod, p) -> Any: ...
def polynomial_reduce_mod(poly, polymod, p) -> Any: ...
@overload
def reduce(function: Callable[[_T, _S], _T], sequence: Iterable[_S], initial: _T) -> _T: ...
@overload
def reduce(function: Callable[[_T, _T], _T], sequence: Iterable[_T]) -> _T: ...
def square_root_mod_prime(a, p) -> Any: ...
